/* -------------------------------------------------------------------------- */
/* (c) ali@balarabe.com                                         [libex_pdf.c] */
/* -------------------------------------------------------------------------- */

#include "libex_c_precompiled.h"
#include "libex_pdf_.h"
#if defined INCLUDED_LIBEX_PDF_H

#include <ctype.h>   /* for tolower() */
#include <stdio.h>
#include <stdlib.h>  /* for atof()    */
#include <string.h>  /* for memset()  */

#if !defined PDF_ZLIB_COMPRESSION
#define PDF_ZLIB_COMPRESSION  0   /* Enable compression with the ZLib library */
#endif
#if defined PDF_ZLIB_COMPRESSION
#include "../../clibs/lib_zlib/zlib.h"
#endif

#include "libex_.h"
#include "libex_bytes_.h"
#include "libex_call_.h"
#include "libex_config_.h"
#include "libex_const_.h"
#include "libex_debug_.h"
#include "libex_error_.h"
#include "libex_macro_.h"
#include "libex_stringc_.h"
#include "libex_type_.h"

#if defined __cplusplus_cli
#pragma unmanaged
#endif

#if defined _MSC_VER
#pragma warning (disable:4710)  /* W:L4 function not inlined */
#endif

#define _START_Y_FROM_TOP  1

/* -------------------------------------------------------------------------- */
/* Local (Private) Macros:                                                    */

#define _WARN_AND_RETURN_IF_NO_PAGE( SRC_UID_, RETURN_VAL_ )  \
    if (me->pages.count == 0 ||                               \
        me->page_no > (me->pages.count - 1) ||                \
        me->page == NULL)                                     \
    {                                                         \
        WARN("No current page.", SRC_UID_);                   \
        RETURN(RETURN_VAL_);                                  \
    }                                                     /*#*/

#define _color_equal( _COLOR_T_1_, _COLOR_T_2_ )                          /*F*/\
    (_COLOR_T_1_.red   == _COLOR_T_2_.red   &&                                 \
     _COLOR_T_1_.green == _COLOR_T_2_.green &&                                 \
     _COLOR_T_1_.blue  == _COLOR_T_2_.blue)                                /*#*/

#define _print_endobj( THIS_ )                                            /*F*/\
    _printf(THIS_, ">>" "\n" "endobj" "\n")                                /*#*/

/* -------------------------------------------------------------------------- */
NAMESPACE(c_)


/* -------------------------------------------------------------------------- */
/* Structures:                                                                */


typedef struct  _array_t {
    size_t    count;                                              /* _array_t */
    size_t    cap;                                                /* _array_t */
    uint8_t*  data;                                               /* _array_t */
}
_array_t;


typedef struct  _color_t {
    uint8_t  red;                                                 /* _color_t */
    uint8_t  green;                                               /* _color_t */
    uint8_t  blue;                                                /* _color_t */
}
_color_t;


typedef struct  _font_type_t {
    uint32_t  font_id;                                        /* _font_type_t */
    char_t    font_name[32];                                  /* _font_type_t */
    bool      standard;                                       /* _font_type_t */
    bool      is_bold;                                        /* _font_type_t */
    bool      italic;                                         /* _font_type_t */
}
_font_type_t;


#if defined _MSC_VER
#pragma warning (push)
#pragma warning (disable:4820)  /* W:L4 'N' bytes padding added after 'NAME'  */
#endif


#if PDF_EXTRA_FEATURES > 0
typedef struct  _named_color_t {
    const char*  name;                                      /* _named_color_t */
    uint8_t      red;                                       /* _named_color_t */
    uint8_t      green;                                     /* _named_color_t */
    uint8_t      blue;                                      /* _named_color_t */
}
_named_color_t;
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


typedef struct  _page_size_t {
    const char*  name;                                        /* _page_size_t */
    pixel_t      width_pt;                                    /* _page_size_t */
    pixel_t      height_pt;                                   /* _page_size_t */
}
_page_size_t;


typedef struct  _string_t {
    size_t  cap;                                                 /* _string_t */
    size_t  len;                                                 /* _string_t */
    char*   chars;                                               /* _string_t */
}
_string_t;


typedef struct  _page_t {
    _page_size_t  page_size;                                       /* _page_t */
    _string_t     page_content;                                    /* _page_t */
    _array_t      font_ids;                                        /* _page_t */

    /* context */
    pixel_t       x;                                               /* _page_t */
    pixel_t       y;                                               /* _page_t */
    pixel_t       line_width;                                      /* _page_t */
    pixel_t       font_size_pt;                                    /* _page_t */
    uint32_t      font_id;                                         /* _page_t */
    _color_t      color_stroke;                                    /* _page_t */
    _color_t      color_non_stroke;                                /* _page_t */
    uint16_t      horizontal_scaling;                              /* _page_t */
}
_page_t;


typedef struct  _pdf_t {
    bool          compress_streams;                                 /* _pdf_t */
    new_chars_t   doc_author;                                       /* _pdf_t */
    new_chars_t   doc_creator;                                      /* _pdf_t */
    new_chars_t   doc_keywords;                                     /* _pdf_t */
    new_chars_t   doc_subject;                                      /* _pdf_t */
    new_chars_t   doc_title;                                        /* _pdf_t */

    _array_t      object_offsets;                                   /* _pdf_t */
    _array_t      pages;                                            /* _pdf_t */
    _array_t      fonts;                                            /* _pdf_t */
    _page_size_t  page_size;                                        /* _pdf_t */
    _string_t     content;                                          /* _pdf_t */

    uint32_t      object_no;                                        /* _pdf_t */
    uint32_t      page_no;                                          /* _pdf_t */
    _page_t*      page;                                             /* _pdf_t */
    _string_t*    content_ref;                                      /* _pdf_t */
    _color_t      color;                                            /* _pdf_t */
    _font_type_t  font;                                             /* _pdf_t */
    pixel_t       font_size_pt;                                     /* _pdf_t */
    pixel_t       line_width;                                       /* _pdf_t */
    uint16_t      horizontal_scaling;                               /* _pdf_t */

#if PDF_EXTRA_FEATURES > 0
    pixel_t       points_per_unit;                                  /* _pdf_t */
    new_chars_t   unit_name;                                        /* _pdf_t */
    pixel_t       page_width_pt;                                    /* _pdf_t */
    pixel_t       page_height_pt;                                   /* _pdf_t */
    size_t        col_count;                                        /* _pdf_t */
    pixel_t*      column_widths;                                    /* _pdf_t */
    uint32_t      column;                                           /* _pdf_t */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */
}
_pdf_t;


#if defined _MSC_VER
#pragma warning (pop)
#endif


/* -------------------------------------------------------------------------- */
/* Data Members: Constant Arrays                                              */


#if PDF_EXTRA_FEATURES > 0
_named_color_t  _COLOR_NAMES[141] = {
    { "aliceblue",            240, 248, 255 },
    { "antiquewhite",         250, 235, 215 },
    { "aqua",                   0, 255, 255 },
    { "aquamarine",           127, 255, 212 },
    { "azure",                240, 255, 255 },
    { "beige",                245, 245, 220 },
    { "bisque",               255, 228, 196 },
    { "black",                  0,   0,   0 },
    { "blanchedalmond",       255, 255, 205 },
    { "blue",                   0,   0, 255 },
    { "blueviolet",           138,  43, 226 },
    { "brown",                165,  42,  42 },
    { "burlywood",            222, 184, 135 },
    { "cadetblue",             95, 158, 160 },
    { "chartreuse",           127, 255,   0 },
    { "chocolate",            210, 105,  30 },
    { "coral",                255, 127,  80 },
    { "cornflowerblue",       100, 149, 237 },
    { "cornsilk",             255, 248, 220 },
    { "crimson",              220,  20,  60 },
    { "cyan",                   0, 255, 255 },
    { "darkblue",               0,   0, 139 },
    { "darkcyan",               0, 139, 139 },
    { "darkgoldenrod",        184, 134,  11 },
    { "darkgray",             169, 169, 169 },
    { "darkgreen",              0, 100,   0 },
    { "darkkhaki",            189, 183, 107 },
    { "darkmagenta",          139,   0, 139 },
    { "darkolivegreen",        85, 107,  47 },
    { "darkorange",           255, 140,   0 },
    { "darkorchid",           153,  50, 204 },
    { "darkred",              139,   0,   0 },
    { "darksalmon",           233, 150, 122 },
    { "darkseagreen",         143, 188, 143 },
    { "darkslateblue",         72,  61, 139 },
    { "darkslategray",         47,  79,  79 },
    { "darkturquoise",          0, 206, 209 },
    { "darkviolet",           148,   0, 211 },
    { "deeppink",             255,  20, 147 },
    { "deepskyblue",            0, 191, 255 },
    { "dimgray",              105, 105, 105 },
    { "dodgerblue",            30, 144, 255 },
    { "firebrick",            178,  34,  34 },
    { "floralwhite",          255, 250, 240 },
    { "forestgreen",           34, 139,  34 },
    { "fuchsia",              255,   0, 255 },
    { "gainsboro",            220, 220, 220 },
    { "ghostwhite",           248, 248, 255 },
    { "gold",                 255, 215,   0 },
    { "goldenrod",            218, 165,  32 },
    { "gray",                 127, 127, 127 },
    { "green",                  0, 128,   0 },
    { "greenyellow",          173, 255,  47 },
    { "honeydew",             240, 255, 240 },
    { "hotpink",              255, 105, 180 },
    { "indianred",            205,  92,  92 },
    { "indigo",                75,   0, 130 },
    { "ivory",                255, 255, 240 },
    { "khaki",                240, 230, 140 },
    { "lavender",             230, 230, 250 },
    { "lavenderblush",        255, 240, 245 },
    { "lawngreen",            124, 252,   0 },
    { "lemonchiffon",         255, 250, 205 },
    { "lightblue",            173, 216, 230 },
    { "lightcoral",           240, 128, 128 },
    { "lightcyan",            224, 255, 255 },
    { "lightgoldenrodyellow", 250, 250, 210 },
    { "lightgray",            211, 211, 211 },
    { "lightgreen",           144, 238, 144 },
    { "lightpink",            255, 182, 193 },
    { "lightsalmon",          255, 160, 122 },
    { "lightseagreen",         32, 178, 170 },
    { "lightskyblue",         135, 206, 250 },
    { "lightslategray",       119, 136, 153 },
    { "lightsteelblue",       176, 196, 222 },
    { "lightyellow",          255, 255, 224 },
    { "lime",                   0, 255,   0 },
    { "limegreen",             50, 205,  50 },
    { "linen",                250, 240, 230 },
    { "magenta",              255,   0, 255 },
    { "maroon",               128,   0,   0 },
    { "mediumaquamarine",     102, 205, 170 },
    { "mediumblue",             0,   0, 205 },
    { "mediumorchid",         186,  85, 211 },
    { "mediumpurple",         147, 112, 219 },
    { "mediumseagreen",        60, 179, 113 },
    { "mediumslateblue",      123, 104, 238 },
    { "mediumspringgreen",      0, 250, 154 },
    { "mediumturquoise",       72, 209, 204 },
    { "mediumvioletred",      199,  21, 133 },
    { "midnightblue",          25,  25, 112 },
    { "mintcream",            245, 255, 250 },
    { "mistyrose",            255, 228, 225 },
    { "moccasin",             255, 228, 181 },
    { "navajowhite",          255, 222, 173 },
    { "navy",                   0,   0, 128 },
    { "navyblue",             159, 175, 223 },
    { "oldlace",              253, 245, 230 },
    { "olive",                128, 128,   0 },
    { "olivedrab",            107, 142,  35 },
    { "orange",               255, 165,   0 },
    { "orangered",            255,  69,   0 },
    { "orchid",               218, 112, 214 },
    { "palegoldenrod",        238, 232, 170 },
    { "palegreen",            152, 251, 152 },
    { "paleturquoise",        175, 238, 238 },
    { "palevioletred",        219, 112, 147 },
    { "papayawhip",           255, 239, 213 },
    { "peachpuff",            255, 218, 185 },
    { "peru",                 205, 133,  63 },
    { "pink",                 255, 192, 203 },
    { "plum",                 221, 160, 221 },
    { "powderblue",           176, 224, 230 },
    { "purple",               128,   0, 128 },
    { "red",                  255,   0,   0 },
    { "rosybrown",            188, 143, 143 },
    { "royalblue",             65, 105, 225 },
    { "saddlebrown",          139,  69,  19 },
    { "salmon",               250, 128, 114 },
    { "sandybrown",           244, 164,  96 },
    { "seagreen",              46, 139,  87 },
    { "seashell",             255, 245, 238 },
    { "sienna",               160,  82,  45 },
    { "silver",               192, 192, 192 },
    { "skyblue",              135, 206, 235 },
    { "slateblue",            106,  90, 205 },
    { "slategray",            112, 128, 144 },
    { "snow",                 255, 250, 250 },
    { "springgreen",            0, 255, 127 },
    { "steelblue",             70, 130, 180 },
    { "tan",                  210, 180, 140 },
    { "teal",                   0, 128, 128 },
    { "thistle",              216, 191, 216 },
    { "tomato",               255,  99,  71 },
    { "turquoise",             64, 224, 208 },
    { "violet",               238, 130, 238 },
    { "wheat",                245, 222, 179 },
    { "white",                255, 255, 255 },
    { "whitesmoke",           245, 245, 245 },
    { "yellow",               255, 255,   0 },
    { "yellowgreen",          139, 205,  50 },
}; /* _COLOR_NAMES */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


chars_t  _STD_FONT_NAMES[14] =  /* array of standard font names */
{
    _T("Courier"),
    _T("Courier-Bold"),
    _T("Courier-BoldOblique"),
    _T("Courier-Oblique"),
    _T("Helvetica"),
    _T("Helvetica-Bold"),
    _T("Helvetica-BoldOblique"),
    _T("Helvetica-Oblique"),
    _T("Symbol"),
    _T("Times-Bold"),
    _T("Times-BoldItalic"),
    _T("Times-Italic"),
    _T("Times-Roman"),
    _T("ZapfDingbats")
};


/*
    Standard font widths:
    "Helvetica", "Helvetica-Bold", "Helvetica-BoldOblique",
    "Helvetica-Oblique", "Symbol", "Times-Bold", "Times-BoldItalic",
    "Times-Italic", "Times-Roman", "ZapfDingbats"
*/

static const int  _WIDTHS_HELVETICA[256] = {
    /*000   */    278,  /*001   */ 278,  /*002   */ 278,  /*003   */ 278,
    /*004   */    278,  /*005   */ 278,  /*006   */ 278,  /*007   */ 278,
    /*008   */    278,  /*009   */ 278,  /*010   */ 278,  /*011   */ 278,
    /*012   */    278,  /*013   */ 278,  /*014   */ 278,  /*015   */ 278,
    /*016   */    278,  /*017   */ 278,  /*018   */ 278,  /*019   */ 278,
    /*020   */    278,  /*021   */ 278,  /*022   */ 278,  /*023   */ 278,
    /*024   */    278,  /*025   */ 278,  /*026   */ 278,  /*027   */ 278,
    /*028   */    278,  /*029   */ 278,  /*030   */ 278,  /*031   */ 278,
    /*032   */    278,  /*033 ! */ 278,  /*034 " */ 355,  /*035 # */ 556,
    /*036 $ */    556,  /*037 % */ 889,  /*038 & */ 667,  /*039 ' */ 191,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 389,  /*043 + */ 584,
    /*044 , */    278,  /*045 - */ 333,  /*046 . */ 278,  /*047 / */ 278,
    /*048 0 */    556,  /*049 1 */ 556,  /*050 2 */ 556,  /*051 3 */ 556,
    /*052 4 */    556,  /*053 5 */ 556,  /*054 6 */ 556,  /*055 7 */ 556,
    /*056 8 */    556,  /*057 9 */ 556,  /*058 : */ 278,  /*059 ; */ 278,
    /*060 < */    584,  /*061 = */ 584,  /*062 > */ 584,  /*063 ? */ 556,
    /*064 @ */    1015, /*065 A */ 667,  /*066 B */ 667,  /*067 C */ 722,
    /*068 d */    722,  /*069 E */ 667,  /*070 F */ 611,  /*071 G */ 778,
    /*072 h */    722,  /*073 i */ 278,  /*074 J */ 500,  /*075 K */ 667,
    /*076 L */    556,  /*077 M */ 833,  /*078 N */ 722,  /*079 O */ 778,
    /*080 p */    667,  /*081 Q */ 778,  /*082 R */ 722,  /*083 S */ 667,
    /*084 T */    611,  /*085 u */ 722,  /*086 V */ 667,  /*087 W */ 944,
    /*088 X */    667,  /*089 Y */ 667,  /*090 Z */ 611,  /*091 [ */ 278,
    /*092 \ */    278,  /*093 ] */ 278,  /*094 ^ */ 469,  /*095 _ */ 556,
    /*096 \x60 */ 333,  /*097 a */ 556,  /*098 b */ 556,  /*099 c */ 500,
    /*100 d */    556,  /*101 e */ 556,  /*102 f */ 278,  /*103 g */ 556,
    /*104 h */    556,  /*105 i */ 222,  /*106 j */ 222,  /*107 k */ 500,
    /*108 l */    222,  /*109 m */ 833,  /*110 n */ 556,  /*111 o */ 556,
    /*112 p */    556,  /*113 q */ 556,  /*114 r */ 333,  /*115 s */ 500,
    /*116 t */    278,  /*117 u */ 556,  /*118 v */ 500,  /*119 w */ 722,
    /*120 x */    500,  /*121 y */ 500,  /*122 z */ 500,  /*123 { */ 334,
    /*124 | */    260,  /*125 } */ 334,  /*126 ~ */ 584,  /*127   */ 350,
    /*128   */    556,  /*129   */ 350,  /*130   */ 222,  /*131   */ 556,
    /*132   */    333,  /*133   */ 1000, /*134   */ 556,  /*135   */ 556,
    /*136   */    333,  /*137   */ 1000, /*138   */ 667,  /*139   */ 333,
    /*140   */    1000, /*141   */ 350,  /*142   */ 611,  /*143   */ 350,
    /*144   */    350,  /*145   */ 222,  /*146   */ 222,  /*147   */ 333,
    /*148   */    333,  /*149   */ 350,  /*150   */ 556,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 1000, /*154   */ 500,  /*155   */ 333,
    /*156   */    944,  /*157   */ 350,  /*158   */ 500,  /*159   */ 667,
    /*160   */    278,  /*161   */ 333,  /*162   */ 556,  /*163   */ 556,
    /*164   */    556,  /*165   */ 556,  /*166   */ 260,  /*167   */ 556,
    /*168   */    333,  /*169   */ 737,  /*170   */ 370,  /*171   */ 556,
    /*172   */    584,  /*173   */ 333,  /*174   */ 737,  /*175   */ 333,
    /*176   */    400,  /*177   */ 584,  /*178   */ 333,  /*179   */ 333,
    /*180   */    333,  /*181   */ 556,  /*182   */ 537,  /*183   */ 278,
    /*184   */    333,  /*185   */ 333,  /*186   */ 365,  /*187   */ 556,
    /*188   */    834,  /*189   */ 834,  /*190   */ 834,  /*191   */ 611,
    /*192   */    667,  /*193   */ 667,  /*194   */ 667,  /*195   */ 667,
    /*196   */    667,  /*197   */ 667,  /*198   */ 1000, /*199   */ 722,
    /*200   */    667,  /*201   */ 667,  /*202   */ 667,  /*203   */ 667,
    /*204   */    278,  /*205   */ 278,  /*206   */ 278,  /*207   */ 278,
    /*208   */    722,  /*209   */ 722,  /*210   */ 778,  /*211   */ 778,
    /*212   */    778,  /*213   */ 778,  /*214   */ 778,  /*215   */ 584,
    /*216   */    778,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 667,  /*222   */ 667,  /*223   */ 611,
    /*224   */    556,  /*225   */ 556,  /*226   */ 556,  /*227   */ 556,
    /*228   */    556,  /*229   */ 556,  /*230   */ 889,  /*231   */ 500,
    /*232   */    556,  /*233   */ 556,  /*234   */ 556,  /*235   */ 556,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    556,  /*241   */ 556,  /*242   */ 556,  /*243   */ 556,
    /*244   */    556,  /*245   */ 556,  /*246   */ 556,  /*247   */ 584,
    /*248   */    611,  /*249   */ 556,  /*250   */ 556,  /*251   */ 556,
    /*252   */    556,  /*253   */ 500,  /*254   */ 556,  /*255   */ 500
};

static const int  _WIDTHS_HELVETICA_BOLD[256] = {
    /*000   */    278,  /*001   */ 278,  /*002   */ 278,  /*003   */ 278,
    /*004   */    278,  /*005   */ 278,  /*006   */ 278,  /*007   */ 278,
    /*008   */    278,  /*009   */ 278,  /*010   */ 278,  /*011   */ 278,
    /*012   */    278,  /*013   */ 278,  /*014   */ 278,  /*015   */ 278,
    /*016   */    278,  /*017   */ 278,  /*018   */ 278,  /*019   */ 278,
    /*020   */    278,  /*021   */ 278,  /*022   */ 278,  /*023   */ 278,
    /*024   */    278,  /*025   */ 278,  /*026   */ 278,  /*027   */ 278,
    /*028   */    278,  /*029   */ 278,  /*030   */ 278,  /*031   */ 278,
    /*032   */    278,  /*033 ! */ 333,  /*034 " */ 474,  /*035 # */ 556,
    /*036 $ */    556,  /*037 % */ 889,  /*038 & */ 722,  /*039 ' */ 238,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 389,  /*043 + */ 584,
    /*044 , */    278,  /*045 - */ 333,  /*046 . */ 278,  /*047 / */ 278,
    /*048 0 */    556,  /*049 1 */ 556,  /*050 2 */ 556,  /*051 3 */ 556,
    /*052 4 */    556,  /*053 5 */ 556,  /*054 6 */ 556,  /*055 7 */ 556,
    /*056 8 */    556,  /*057 9 */ 556,  /*058 : */ 333,  /*059 ; */ 333,
    /*060 < */    584,  /*061 = */ 584,  /*062 > */ 584,  /*063 ? */ 611,
    /*064 @ */    975,  /*065 A */ 722,  /*066 B */ 722,  /*067 C */ 722,
    /*068 d */    722,  /*069 E */ 667,  /*070 F */ 611,  /*071 G */ 778,
    /*072 h */    722,  /*073 i */ 278,  /*074 J */ 556,  /*075 K */ 722,
    /*076 L */    611,  /*077 M */ 833,  /*078 N */ 722,  /*079 O */ 778,
    /*080 p */    667,  /*081 Q */ 778,  /*082 R */ 722,  /*083 S */ 667,
    /*084 T */    611,  /*085 u */ 722,  /*086 V */ 667,  /*087 W */ 944,
    /*088 X */    667,  /*089 Y */ 667,  /*090 Z */ 611,  /*091 [ */ 333,
    /*092 \ */    278,  /*093 ] */ 333,  /*094 ^ */ 584,  /*095 _ */ 556,
    /*096 \x60 */ 333,  /*097 a */ 556,  /*098 b */ 611,  /*099 c */ 556,
    /*100 d */    611,  /*101 e */ 556,  /*102 f */ 333,  /*103 g */ 611,
    /*104 h */    611,  /*105 i */ 278,  /*106 j */ 278,  /*107 k */ 556,
    /*108 l */    278,  /*109 m */ 889,  /*110 n */ 611,  /*111 o */ 611,
    /*112 p */    611,  /*113 q */ 611,  /*114 r */ 389,  /*115 s */ 556,
    /*116 t */    333,  /*117 u */ 611,  /*118 v */ 556,  /*119 w */ 778,
    /*120 x */    556,  /*121 y */ 556,  /*122 z */ 500,  /*123 { */ 389,
    /*124 | */    280,  /*125 } */ 389,  /*126 ~ */ 584,  /*127   */ 350,
    /*128   */    556,  /*129   */ 350,  /*130   */ 278,  /*131   */ 556,
    /*132   */    500,  /*133   */ 1000, /*134   */ 556,  /*135   */ 556,
    /*136   */    333,  /*137   */ 1000, /*138   */ 667,  /*139   */ 333,
    /*140   */    1000, /*141   */ 350,  /*142   */ 611,  /*143   */ 350,
    /*144   */    350,  /*145   */ 278,  /*146   */ 278,  /*147   */ 500,
    /*148   */    500,  /*149   */ 350,  /*150   */ 556,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 1000, /*154   */ 556,  /*155   */ 333,
    /*156   */    944,  /*157   */ 350,  /*158   */ 500,  /*159   */ 667,
    /*160   */    278,  /*161   */ 333,  /*162   */ 556,  /*163   */ 556,
    /*164   */    556,  /*165   */ 556,  /*166   */ 280,  /*167   */ 556,
    /*168   */    333,  /*169   */ 737,  /*170   */ 370,  /*171   */ 556,
    /*172   */    584,  /*173   */ 333,  /*174   */ 737,  /*175   */ 333,
    /*176   */    400,  /*177   */ 584,  /*178   */ 333,  /*179   */ 333,
    /*180   */    333,  /*181   */ 611,  /*182   */ 556,  /*183   */ 278,
    /*184   */    333,  /*185   */ 333,  /*186   */ 365,  /*187   */ 556,
    /*188   */    834,  /*189   */ 834,  /*190   */ 834,  /*191   */ 611,
    /*192   */    722,  /*193   */ 722,  /*194   */ 722,  /*195   */ 722,
    /*196   */    722,  /*197   */ 722,  /*198   */ 1000, /*199   */ 722,
    /*200   */    667,  /*201   */ 667,  /*202   */ 667,  /*203   */ 667,
    /*204   */    278,  /*205   */ 278,  /*206   */ 278,  /*207   */ 278,
    /*208   */    722,  /*209   */ 722,  /*210   */ 778,  /*211   */ 778,
    /*212   */    778,  /*213   */ 778,  /*214   */ 778,  /*215   */ 584,
    /*216   */    778,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 667,  /*222   */ 667,  /*223   */ 611,
    /*224   */    556,  /*225   */ 556,  /*226   */ 556,  /*227   */ 556,
    /*228   */    556,  /*229   */ 556,  /*230   */ 889,  /*231   */ 556,
    /*232   */    556,  /*233   */ 556,  /*234   */ 556,  /*235   */ 556,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    611,  /*241   */ 611,  /*242   */ 611,  /*243   */ 611,
    /*244   */    611,  /*245   */ 611,  /*246   */ 611,  /*247   */ 584,
    /*248   */    611,  /*249   */ 611,  /*250   */ 611,  /*251   */ 611,
    /*252   */    611,  /*253   */ 556,  /*254   */ 611,  /*255   */ 556
};

static const int  _WIDTHS_HELVETICA_BOLD_OBLIQUE[256] = {
    /*000   */    278,  /*001   */ 278,  /*002   */ 278,  /*003   */ 278,
    /*004   */    278,  /*005   */ 278,  /*006   */ 278,  /*007   */ 278,
    /*008   */    278,  /*009   */ 278,  /*010   */ 278,  /*011   */ 278,
    /*012   */    278,  /*013   */ 278,  /*014   */ 278,  /*015   */ 278,
    /*016   */    278,  /*017   */ 278,  /*018   */ 278,  /*019   */ 278,
    /*020   */    278,  /*021   */ 278,  /*022   */ 278,  /*023   */ 278,
    /*024   */    278,  /*025   */ 278,  /*026   */ 278,  /*027   */ 278,
    /*028   */    278,  /*029   */ 278,  /*030   */ 278,  /*031   */ 278,
    /*032   */    278,  /*033 ! */ 333,  /*034 " */ 474,  /*035 # */ 556,
    /*036 $ */    556,  /*037 % */ 889,  /*038 & */ 722,  /*039 ' */ 238,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 389,  /*043 + */ 584,
    /*044 , */    278,  /*045 - */ 333,  /*046 . */ 278,  /*047 / */ 278,
    /*048 0 */    556,  /*049 1 */ 556,  /*050 2 */ 556,  /*051 3 */ 556,
    /*052 4 */    556,  /*053 5 */ 556,  /*054 6 */ 556,  /*055 7 */ 556,
    /*056 8 */    556,  /*057 9 */ 556,  /*058 : */ 333,  /*059 ; */ 333,
    /*060 < */    584,  /*061 = */ 584,  /*062 > */ 584,  /*063 ? */ 611,
    /*064 @ */    975,  /*065 A */ 722,  /*066 B */ 722,  /*067 C */ 722,
    /*068 d */    722,  /*069 E */ 667,  /*070 F */ 611,  /*071 G */ 778,
    /*072 h */    722,  /*073 i */ 278,  /*074 J */ 556,  /*075 K */ 722,
    /*076 L */    611,  /*077 M */ 833,  /*078 N */ 722,  /*079 O */ 778,
    /*080 p */    667,  /*081 Q */ 778,  /*082 R */ 722,  /*083 S */ 667,
    /*084 T */    611,  /*085 u */ 722,  /*086 V */ 667,  /*087 W */ 944,
    /*088 X */    667,  /*089 Y */ 667,  /*090 Z */ 611,  /*091 [ */ 333,
    /*092 \ */    278,  /*093 ] */ 333,  /*094 ^ */ 584,  /*095 _ */ 556,
    /*096 \x60 */ 333,  /*097 a */ 556,  /*098 b */ 611,  /*099 c */ 556,
    /*100 d */    611,  /*101 e */ 556,  /*102 f */ 333,  /*103 g */ 611,
    /*104 h */    611,  /*105 i */ 278,  /*106 j */ 278,  /*107 k */ 556,
    /*108 l */    278,  /*109 m */ 889,  /*110 n */ 611,  /*111 o */ 611,
    /*112 p */    611,  /*113 q */ 611,  /*114 r */ 389,  /*115 s */ 556,
    /*116 t */    333,  /*117 u */ 611,  /*118 v */ 556,  /*119 w */ 778,
    /*120 x */    556,  /*121 y */ 556,  /*122 z */ 500,  /*123 { */ 389,
    /*124 | */    280,  /*125 } */ 389,  /*126 ~ */ 584,  /*127   */ 350,
    /*128   */    556,  /*129   */ 350,  /*130   */ 278,  /*131   */ 556,
    /*132   */    500,  /*133   */ 1000, /*134   */ 556,  /*135   */ 556,
    /*136   */    333,  /*137   */ 1000, /*138   */ 667,  /*139   */ 333,
    /*140   */    1000, /*141   */ 350,  /*142   */ 611,  /*143   */ 350,
    /*144   */    350,  /*145   */ 278,  /*146   */ 278,  /*147   */ 500,
    /*148   */    500,  /*149   */ 350,  /*150   */ 556,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 1000, /*154   */ 556,  /*155   */ 333,
    /*156   */    944,  /*157   */ 350,  /*158   */ 500,  /*159   */ 667,
    /*160   */    278,  /*161   */ 333,  /*162   */ 556,  /*163   */ 556,
    /*164   */    556,  /*165   */ 556,  /*166   */ 280,  /*167   */ 556,
    /*168   */    333,  /*169   */ 737,  /*170   */ 370,  /*171   */ 556,
    /*172   */    584,  /*173   */ 333,  /*174   */ 737,  /*175   */ 333,
    /*176   */    400,  /*177   */ 584,  /*178   */ 333,  /*179   */ 333,
    /*180   */    333,  /*181   */ 611,  /*182   */ 556,  /*183   */ 278,
    /*184   */    333,  /*185   */ 333,  /*186   */ 365,  /*187   */ 556,
    /*188   */    834,  /*189   */ 834,  /*190   */ 834,  /*191   */ 611,
    /*192   */    722,  /*193   */ 722,  /*194   */ 722,  /*195   */ 722,
    /*196   */    722,  /*197   */ 722,  /*198   */ 1000, /*199   */ 722,
    /*200   */    667,  /*201   */ 667,  /*202   */ 667,  /*203   */ 667,
    /*204   */    278,  /*205   */ 278,  /*206   */ 278,  /*207   */ 278,
    /*208   */    722,  /*209   */ 722,  /*210   */ 778,  /*211   */ 778,
    /*212   */    778,  /*213   */ 778,  /*214   */ 778,  /*215   */ 584,
    /*216   */    778,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 667,  /*222   */ 667,  /*223   */ 611,
    /*224   */    556,  /*225   */ 556,  /*226   */ 556,  /*227   */ 556,
    /*228   */    556,  /*229   */ 556,  /*230   */ 889,  /*231   */ 556,
    /*232   */    556,  /*233   */ 556,  /*234   */ 556,  /*235   */ 556,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    611,  /*241   */ 611,  /*242   */ 611,  /*243   */ 611,
    /*244   */    611,  /*245   */ 611,  /*246   */ 611,  /*247   */ 584,
    /*248   */    611,  /*249   */ 611,  /*250   */ 611,  /*251   */ 611,
    /*252   */    611,  /*253   */ 556,  /*254   */ 611,  /*255   */ 556
};

static const int  _WIDTHS_HELVETICA_OBLIQUE[256] = {
    /*000   */    278,  /*001   */ 278,  /*002   */ 278,  /*003   */ 278,
    /*004   */    278,  /*005   */ 278,  /*006   */ 278,  /*007   */ 278,
    /*008   */    278,  /*009   */ 278,  /*010   */ 278,  /*011   */ 278,
    /*012   */    278,  /*013   */ 278,  /*014   */ 278,  /*015   */ 278,
    /*016   */    278,  /*017   */ 278,  /*018   */ 278,  /*019   */ 278,
    /*020   */    278,  /*021   */ 278,  /*022   */ 278,  /*023   */ 278,
    /*024   */    278,  /*025   */ 278,  /*026   */ 278,  /*027   */ 278,
    /*028   */    278,  /*029   */ 278,  /*030   */ 278,  /*031   */ 278,
    /*032   */    278,  /*033 ! */ 278,  /*034 " */ 355,  /*035 # */ 556,
    /*036 $ */    556,  /*037 % */ 889,  /*038 & */ 667,  /*039 ' */ 191,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 389,  /*043 + */ 584,
    /*044 , */    278,  /*045 - */ 333,  /*046 . */ 278,  /*047 / */ 278,
    /*048 0 */    556,  /*049 1 */ 556,  /*050 2 */ 556,  /*051 3 */ 556,
    /*052 4 */    556,  /*053 5 */ 556,  /*054 6 */ 556,  /*055 7 */ 556,
    /*056 8 */    556,  /*057 9 */ 556,  /*058 : */ 278,  /*059 ; */ 278,
    /*060 < */    584,  /*061 = */ 584,  /*062 > */ 584,  /*063 ? */ 556,
    /*064 @ */    1015, /*065 A */ 667,  /*066 B */ 667,  /*067 C */ 722,
    /*068 d */    722,  /*069 E */ 667,  /*070 F */ 611,  /*071 G */ 778,
    /*072 h */    722,  /*073 i */ 278,  /*074 J */ 500,  /*075 K */ 667,
    /*076 L */    556,  /*077 M */ 833,  /*078 N */ 722,  /*079 O */ 778,
    /*080 p */    667,  /*081 Q */ 778,  /*082 R */ 722,  /*083 S */ 667,
    /*084 T */    611,  /*085 u */ 722,  /*086 V */ 667,  /*087 W */ 944,
    /*088 X */    667,  /*089 Y */ 667,  /*090 Z */ 611,  /*091 [ */ 278,
    /*092 \ */    278,  /*093 ] */ 278,  /*094 ^ */ 469,  /*095 _ */ 556,
    /*096 \x60 */ 333,  /*097 a */ 556,  /*098 b */ 556,  /*099 c */ 500,
    /*100 d */    556,  /*101 e */ 556,  /*102 f */ 278,  /*103 g */ 556,
    /*104 h */    556,  /*105 i */ 222,  /*106 j */ 222,  /*107 k */ 500,
    /*108 l */    222,  /*109 m */ 833,  /*110 n */ 556,  /*111 o */ 556,
    /*112 p */    556,  /*113 q */ 556,  /*114 r */ 333,  /*115 s */ 500,
    /*116 t */    278,  /*117 u */ 556,  /*118 v */ 500,  /*119 w */ 722,
    /*120 x */    500,  /*121 y */ 500,  /*122 z */ 500,  /*123 { */ 334,
    /*124 | */    260,  /*125 } */ 334,  /*126 ~ */ 584,  /*127   */ 350,
    /*128   */    556,  /*129   */ 350,  /*130   */ 222,  /*131   */ 556,
    /*132   */    333,  /*133   */ 1000, /*134   */ 556,  /*135   */ 556,
    /*136   */    333,  /*137   */ 1000, /*138   */ 667,  /*139   */ 333,
    /*140   */    1000, /*141   */ 350,  /*142   */ 611,  /*143   */ 350,
    /*144   */    350,  /*145   */ 222,  /*146   */ 222,  /*147   */ 333,
    /*148   */    333,  /*149   */ 350,  /*150   */ 556,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 1000, /*154   */ 500,  /*155   */ 333,
    /*156   */    944,  /*157   */ 350,  /*158   */ 500,  /*159   */ 667,
    /*160   */    278,  /*161   */ 333,  /*162   */ 556,  /*163   */ 556,
    /*164   */    556,  /*165   */ 556,  /*166   */ 260,  /*167   */ 556,
    /*168   */    333,  /*169   */ 737,  /*170   */ 370,  /*171   */ 556,
    /*172   */    584,  /*173   */ 333,  /*174   */ 737,  /*175   */ 333,
    /*176   */    400,  /*177   */ 584,  /*178   */ 333,  /*179   */ 333,
    /*180   */    333,  /*181   */ 556,  /*182   */ 537,  /*183   */ 278,
    /*184   */    333,  /*185   */ 333,  /*186   */ 365,  /*187   */ 556,
    /*188   */    834,  /*189   */ 834,  /*190   */ 834,  /*191   */ 611,
    /*192   */    667,  /*193   */ 667,  /*194   */ 667,  /*195   */ 667,
    /*196   */    667,  /*197   */ 667,  /*198   */ 1000, /*199   */ 722,
    /*200   */    667,  /*201   */ 667,  /*202   */ 667,  /*203   */ 667,
    /*204   */    278,  /*205   */ 278,  /*206   */ 278,  /*207   */ 278,
    /*208   */    722,  /*209   */ 722,  /*210   */ 778,  /*211   */ 778,
    /*212   */    778,  /*213   */ 778,  /*214   */ 778,  /*215   */ 584,
    /*216   */    778,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 667,  /*222   */ 667,  /*223   */ 611,
    /*224   */    556,  /*225   */ 556,  /*226   */ 556,  /*227   */ 556,
    /*228   */    556,  /*229   */ 556,  /*230   */ 889,  /*231   */ 500,
    /*232   */    556,  /*233   */ 556,  /*234   */ 556,  /*235   */ 556,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    556,  /*241   */ 556,  /*242   */ 556,  /*243   */ 556,
    /*244   */    556,  /*245   */ 556,  /*246   */ 556,  /*247   */ 584,
    /*248   */    611,  /*249   */ 556,  /*250   */ 556,  /*251   */ 556,
    /*252   */    556,  /*253   */ 500,  /*254   */ 556,  /*255   */ 500
};

static const int  _WIDTHS_SYMBOL[256] = {
    /*000   */    250,  /*001   */ 250,  /*002   */ 250,  /*003   */ 250,
    /*004   */    250,  /*005   */ 250,  /*006   */ 250,  /*007   */ 250,
    /*008   */    250,  /*009   */ 250,  /*010   */ 250,  /*011   */ 250,
    /*012   */    250,  /*013   */ 250,  /*014   */ 250,  /*015   */ 250,
    /*016   */    250,  /*017   */ 250,  /*018   */ 250,  /*019   */ 250,
    /*020   */    250,  /*021   */ 250,  /*022   */ 250,  /*023   */ 250,
    /*024   */    250,  /*025   */ 250,  /*026   */ 250,  /*027   */ 250,
    /*028   */    250,  /*029   */ 250,  /*030   */ 250,  /*031   */ 250,
    /*032   */    250,  /*033 ! */ 333,  /*034 " */ 713,  /*035 # */ 500,
    /*036 $ */    549,  /*037 % */ 833,  /*038 & */ 778,  /*039 ' */ 439,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 500,  /*043 + */ 549,
    /*044 , */    250,  /*045 - */ 549,  /*046 . */ 250,  /*047 / */ 278,
    /*048 0 */    500,  /*049 1 */ 500,  /*050 2 */ 500,  /*051 3 */ 500,
    /*052 4 */    500,  /*053 5 */ 500,  /*054 6 */ 500,  /*055 7 */ 500,
    /*056 8 */    500,  /*057 9 */ 500,  /*058 : */ 278,  /*059 ; */ 278,
    /*060 < */    549,  /*061 = */ 549,  /*062 > */ 549,  /*063 ? */ 444,
    /*064 @ */    549,  /*065 A */ 722,  /*066 B */ 667,  /*067 C */ 722,
    /*068 d */    612,  /*069 E */ 611,  /*070 F */ 763,  /*071 G */ 603,
    /*072 h */    722,  /*073 i */ 333,  /*074 J */ 631,  /*075 K */ 722,
    /*076 L */    686,  /*077 M */ 889,  /*078 N */ 722,  /*079 O */ 722,
    /*080 p */    768,  /*081 Q */ 741,  /*082 R */ 556,  /*083 S */ 592,
    /*084 T */    611,  /*085 u */ 690,  /*086 V */ 439,  /*087 W */ 768,
    /*088 X */    645,  /*089 Y */ 795,  /*090 Z */ 611,  /*091 [ */ 333,
    /*092 \ */    863,  /*093 ] */ 333,  /*094 ^ */ 658,  /*095 _ */ 500,
    /*096 \x60 */ 500,  /*097 a */ 631,  /*098 b */ 549,  /*099 c */ 549,
    /*100 d */    494,  /*101 e */ 439,  /*102 f */ 521,  /*103 g */ 411,
    /*104 h */    603,  /*105 i */ 329,  /*106 j */ 603,  /*107 k */ 549,
    /*108 l */    549,  /*109 m */ 576,  /*110 n */ 521,  /*111 o */ 549,
    /*112 p */    549,  /*113 q */ 521,  /*114 r */ 549,  /*115 s */ 603,
    /*116 t */    439,  /*117 u */ 576,  /*118 v */ 713,  /*119 w */ 686,
    /*120 x */    493,  /*121 y */ 686,  /*122 z */ 494,  /*123 { */ 480,
    /*124 | */    200,  /*125 } */ 480,  /*126 ~ */ 549,  /*127   */ 000,
    /*128   */    0,    /*129   */ 0,    /*130   */ 0,    /*131   */ 0,
    /*132   */    0,    /*133   */ 0,    /*134   */ 0,    /*135   */ 0,
    /*136   */    0,    /*137   */ 0,    /*138   */ 0,    /*139   */ 0,
    /*140   */    0,    /*141   */ 0,    /*142   */ 0,    /*143   */ 0,
    /*144   */    0,    /*145   */ 0,    /*146   */ 0,    /*147   */ 0,
    /*148   */    0,    /*149   */ 0,    /*150   */ 0,    /*151   */ 0,
    /*152   */    0,    /*153   */ 0,    /*154   */ 0,    /*155   */ 0,
    /*156   */    0,    /*157   */ 0,    /*158   */ 0,    /*159   */ 0,
    /*160   */    750,  /*161   */ 620,  /*162   */ 247,  /*163   */ 549,
    /*164   */    167,  /*165   */ 713,  /*166   */ 500,  /*167   */ 753,
    /*168   */    753,  /*169   */ 753,  /*170   */ 753,  /*171   */ 1042,
    /*172   */    987,  /*173   */ 603,  /*174   */ 987,  /*175   */ 603,
    /*176   */    400,  /*177   */ 549,  /*178   */ 411,  /*179   */ 549,
    /*180   */    549,  /*181   */ 713,  /*182   */ 494,  /*183   */ 460,
    /*184   */    549,  /*185   */ 549,  /*186   */ 549,  /*187   */ 549,
    /*188   */    1000, /*189   */ 603,  /*190   */ 1000, /*191   */ 658,
    /*192   */    823,  /*193   */ 686,  /*194   */ 795,  /*195   */ 987,
    /*196   */    768,  /*197   */ 768,  /*198   */ 823,  /*199   */ 768,
    /*200   */    768,  /*201   */ 713,  /*202   */ 713,  /*203   */ 713,
    /*204   */    713,  /*205   */ 713,  /*206   */ 713,  /*207   */ 713,
    /*208   */    768,  /*209   */ 713,  /*210   */ 790,  /*211   */ 790,
    /*212   */    890,  /*213   */ 823,  /*214   */ 549,  /*215   */ 250,
    /*216   */    713,  /*217   */ 603,  /*218   */ 603,  /*219   */ 1042,
    /*220   */    987,  /*221   */ 603,  /*222   */ 987,  /*223   */ 603,
    /*224   */    494,  /*225   */ 329,  /*226   */ 790,  /*227   */ 790,
    /*228   */    786,  /*229   */ 713,  /*230   */ 384,  /*231   */ 384,
    /*232   */    384,  /*233   */ 384,  /*234   */ 384,  /*235   */ 384,
    /*236   */    494,  /*237   */ 494,  /*238   */ 494,  /*239   */ 494,
    /*240   */    0,    /*241   */ 329,  /*242   */ 274,  /*243   */ 686,
    /*244   */    686,  /*245   */ 686,  /*246   */ 384,  /*247   */ 384,
    /*248   */    384,  /*249   */ 384,  /*250   */ 384,  /*251   */ 384,
    /*252   */    494,  /*253   */ 494,  /*254   */ 494,  /*255   */ 0
};

static const int  _WIDTHS_TIMES_BOLD[256] = {
    /*000   */    250,  /*001   */ 250,  /*002   */ 250,  /*003   */ 250,
    /*004   */    250,  /*005   */ 250,  /*006   */ 250,  /*007   */ 250,
    /*008   */    250,  /*009   */ 250,  /*010   */ 250,  /*011   */ 250,
    /*012   */    250,  /*013   */ 250,  /*014   */ 250,  /*015   */ 250,
    /*016   */    250,  /*017   */ 250,  /*018   */ 250,  /*019   */ 250,
    /*020   */    250,  /*021   */ 250,  /*022   */ 250,  /*023   */ 250,
    /*024   */    250,  /*025   */ 250,  /*026   */ 250,  /*027   */ 250,
    /*028   */    250,  /*029   */ 250,  /*030   */ 250,  /*031   */ 250,
    /*032   */    250,  /*033 ! */ 333,  /*034 " */ 555,  /*035 # */ 500,
    /*036 $ */    500,  /*037 % */ 0,    /*038 & */ 833,  /*039 ' */ 278,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 500,  /*043 + */ 570,
    /*044 , */    250,  /*045 - */ 333,  /*046 . */ 250,  /*047 / */ 278,
    /*048 0 */    500,  /*049 1 */ 500,  /*050 2 */ 500,  /*051 3 */ 500,
    /*052 4 */    500,  /*053 5 */ 500,  /*054 6 */ 500,  /*055 7 */ 500,
    /*056 8 */    500,  /*057 9 */ 500,  /*058 : */ 333,  /*059 ; */ 333,
    /*060 < */    570,  /*061 = */ 570,  /*062 > */ 570,  /*063 ? */ 500,
    /*064 @ */    930,  /*065 A */ 722,  /*066 B */ 667,  /*067 C */ 722,
    /*068 d */    722,  /*069 E */ 667,  /*070 F */ 611,  /*071 G */ 778,
    /*072 h */    778,  /*073 i */ 389,  /*074 J */ 500,  /*075 K */ 778,
    /*076 L */    667,  /*077 M */ 944,  /*078 N */ 722,  /*079 O */ 778,
    /*080 p */    611,  /*081 Q */ 778,  /*082 R */ 722,  /*083 S */ 556,
    /*084 T */    667,  /*085 u */ 722,  /*086 V */ 722,  /*087 W */ 1000,
    /*088 X */    722,  /*089 Y */ 722,  /*090 Z */ 667,  /*091 [ */ 333,
    /*092 \ */    278,  /*093 ] */ 333,  /*094 ^ */ 581,  /*095 _ */ 500,
    /*096 \x60 */ 333,  /*097 a */ 500,  /*098 b */ 556,  /*099 c */ 444,
    /*100 d */    556,  /*101 e */ 444,  /*102 f */ 333,  /*103 g */ 500,
    /*104 h */    556,  /*105 i */ 278,  /*106 j */ 333,  /*107 k */ 556,
    /*108 l */    278,  /*109 m */ 833,  /*110 n */ 556,  /*111 o */ 500,
    /*112 p */    556,  /*113 q */ 556,  /*114 r */ 444,  /*115 s */ 389,
    /*116 t */    333,  /*117 u */ 556,  /*118 v */ 500,  /*119 w */ 722,
    /*120 x */    500,  /*121 y */ 500,  /*122 z */ 444,  /*123 { */ 394,
    /*124 | */    220,  /*125 } */ 394,  /*126 ~ */ 520,  /*127   */ 350,
    /*128   */    500,  /*129   */ 350,  /*130   */ 333,  /*131   */ 500,
    /*132   */    500,  /*133   */ 1000, /*134   */ 500,  /*135   */ 500,
    /*136   */    333,  /*137   */ 1000, /*138   */ 556,  /*139   */ 333,
    /*140   */    1000, /*141   */ 350,  /*142   */ 667,  /*143   */ 350,
    /*144   */    350,  /*145   */ 333,  /*146   */ 333,  /*147   */ 500,
    /*148   */    500,  /*149   */ 350,  /*150   */ 500,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 1000, /*154   */ 389,  /*155   */ 333,
    /*156   */    722,  /*157   */ 350,  /*158   */ 444,  /*159   */ 722,
    /*160   */    250,  /*161   */ 333,  /*162   */ 500,  /*163   */ 500,
    /*164   */    500,  /*165   */ 500,  /*166   */ 220,  /*167   */ 500,
    /*168   */    333,  /*169   */ 747,  /*170   */ 300,  /*171   */ 500,
    /*172   */    570,  /*173   */ 333,  /*174   */ 747,  /*175   */ 333,
    /*176   */    400,  /*177   */ 570,  /*178   */ 300,  /*179   */ 300,
    /*180   */    333,  /*181   */ 556,  /*182   */ 540,  /*183   */ 250,
    /*184   */    333,  /*185   */ 300,  /*186   */ 330,  /*187   */ 500,
    /*188   */    750,  /*189   */ 750,  /*190   */ 750,  /*191   */ 500,
    /*192   */    722,  /*193   */ 722,  /*194   */ 722,  /*195   */ 722,
    /*196   */    722,  /*197   */ 722,  /*198   */ 1000, /*199   */ 722,
    /*200   */    667,  /*201   */ 667,  /*202   */ 667,  /*203   */ 667,
    /*204   */    389,  /*205   */ 389,  /*206   */ 389,  /*207   */ 389,
    /*208   */    722,  /*209   */ 722,  /*210   */ 778,  /*211   */ 778,
    /*212   */    778,  /*213   */ 778,  /*214   */ 778,  /*215   */ 570,
    /*216   */    778,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 722,  /*222   */ 611,  /*223   */ 556,
    /*224   */    500,  /*225   */ 500,  /*226   */ 500,  /*227   */ 500,
    /*228   */    500,  /*229   */ 500,  /*230   */ 722,  /*231   */ 444,
    /*232   */    444,  /*233   */ 444,  /*234   */ 444,  /*235   */ 444,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    500,  /*241   */ 556,  /*242   */ 500,  /*243   */ 500,
    /*244   */    500,  /*245   */ 500,  /*246   */ 500,  /*247   */ 570,
    /*248   */    500,  /*249   */ 556,  /*250   */ 556,  /*251   */ 556,
    /*252   */    556,  /*253   */ 500,  /*254   */ 556,  /*255   */ 500
};

static const int  _WIDTHS_TIMES_BOLD_ITALIC[256] = {
    /*000   */    250,  /*001   */ 250,  /*002   */ 250,  /*003   */ 250,
    /*004   */    250,  /*005   */ 250,  /*006   */ 250,  /*007   */ 250,
    /*008   */    250,  /*009   */ 250,  /*010   */ 250,  /*011   */ 250,
    /*012   */    250,  /*013   */ 250,  /*014   */ 250,  /*015   */ 250,
    /*016   */    250,  /*017   */ 250,  /*018   */ 250,  /*019   */ 250,
    /*020   */    250,  /*021   */ 250,  /*022   */ 250,  /*023   */ 250,
    /*024   */    250,  /*025   */ 250,  /*026   */ 250,  /*027   */ 250,
    /*028   */    250,  /*029   */ 250,  /*030   */ 250,  /*031   */ 250,
    /*032   */    250,  /*033 ! */ 389,  /*034 " */ 555,  /*035 # */ 500,
    /*036 $ */    500,  /*037 % */ 833,  /*038 & */ 778,  /*039 ' */ 278,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 500,  /*043 + */ 570,
    /*044 , */    250,  /*045 - */ 333,  /*046 . */ 250,  /*047 / */ 278,
    /*048 0 */    500,  /*049 1 */ 500,  /*050 2 */ 500,  /*051 3 */ 500,
    /*052 4 */    500,  /*053 5 */ 500,  /*054 6 */ 500,  /*055 7 */ 500,
    /*056 8 */    500,  /*057 9 */ 500,  /*058 : */ 333,  /*059 ; */ 333,
    /*060 < */    570,  /*061 = */ 570,  /*062 > */ 570,  /*063 ? */ 500,
    /*064 @ */    832,  /*065 A */ 667,  /*066 B */ 667,  /*067 C */ 667,
    /*068 d */    722,  /*069 E */ 667,  /*070 F */ 667,  /*071 G */ 722,
    /*072 h */    778,  /*073 i */ 389,  /*074 J */ 500,  /*075 K */ 667,
    /*076 L */    611,  /*077 M */ 889,  /*078 N */ 722,  /*079 O */ 722,
    /*080 p */    611,  /*081 Q */ 722,  /*082 R */ 667,  /*083 S */ 556,
    /*084 T */    611,  /*085 u */ 722,  /*086 V */ 667,  /*087 W */ 889,
    /*088 X */    667,  /*089 Y */ 611,  /*090 Z */ 611,  /*091 [ */ 333,
    /*092 \ */    278,  /*093 ] */ 333,  /*094 ^ */ 570,  /*095 _ */ 500,
    /*096 \x60 */ 333,  /*097 a */ 500,  /*098 b */ 500,  /*099 c */ 444,
    /*100 d */    500,  /*101 e */ 444,  /*102 f */ 333,  /*103 g */ 500,
    /*104 h */    556,  /*105 i */ 278,  /*106 j */ 278,  /*107 k */ 500,
    /*108 l */    278,  /*109 m */ 778,  /*110 n */ 556,  /*111 o */ 500,
    /*112 p */    500,  /*113 q */ 500,  /*114 r */ 389,  /*115 s */ 389,
    /*116 t */    278,  /*117 u */ 556,  /*118 v */ 444,  /*119 w */ 667,
    /*120 x */    500,  /*121 y */ 444,  /*122 z */ 389,  /*123 { */ 348,
    /*124 | */    220,  /*125 } */ 348,  /*126 ~ */ 570,  /*127   */ 350,
    /*128   */    500,  /*129   */ 350,  /*130   */ 333,  /*131   */ 500,
    /*132   */    500,  /*133   */ 1000, /*134   */ 500,  /*135   */ 500,
    /*136   */    333,  /*137   */ 1000, /*138   */ 556,  /*139   */ 333,
    /*140   */    944,  /*141   */ 350,  /*142   */ 611,  /*143   */ 350,
    /*144   */    350,  /*145   */ 333,  /*146   */ 333,  /*147   */ 500,
    /*148   */    500,  /*149   */ 350,  /*150   */ 500,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 1000, /*154   */ 389,  /*155   */ 333,
    /*156   */    722,  /*157   */ 350,  /*158   */ 389,  /*159   */ 611,
    /*160   */    250,  /*161   */ 389,  /*162   */ 500,  /*163   */ 500,
    /*164   */    500,  /*165   */ 500,  /*166   */ 220,  /*167   */ 500,
    /*168   */    333,  /*169   */ 747,  /*170   */ 266,  /*171   */ 500,
    /*172   */    606,  /*173   */ 333,  /*174   */ 747,  /*175   */ 333,
    /*176   */    400,  /*177   */ 570,  /*178   */ 300,  /*179   */ 300,
    /*180   */    333,  /*181   */ 576,  /*182   */ 500,  /*183   */ 250,
    /*184   */    333,  /*185   */ 300,  /*186   */ 300,  /*187   */ 500,
    /*188   */    750,  /*189   */ 750,  /*190   */ 750,  /*191   */ 500,
    /*192   */    667,  /*193   */ 667,  /*194   */ 667,  /*195   */ 667,
    /*196   */    667,  /*197   */ 667,  /*198   */ 944,  /*199   */ 667,
    /*200   */    667,  /*201   */ 667,  /*202   */ 667,  /*203   */ 667,
    /*204   */    389,  /*205   */ 389,  /*206   */ 389,  /*207   */ 389,
    /*208   */    722,  /*209   */ 722,  /*210   */ 722,  /*211   */ 722,
    /*212   */    722,  /*213   */ 722,  /*214   */ 722,  /*215   */ 570,
    /*216   */    722,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 611,  /*222   */ 611,  /*223   */ 500,
    /*224   */    500,  /*225   */ 500,  /*226   */ 500,  /*227   */ 500,
    /*228   */    500,  /*229   */ 500,  /*230   */ 722,  /*231   */ 444,
    /*232   */    444,  /*233   */ 444,  /*234   */ 444,  /*235   */ 444,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    500,  /*241   */ 556,  /*242   */ 500,  /*243   */ 500,
    /*244   */    500,  /*245   */ 500,  /*246   */ 500,  /*247   */ 570,
    /*248   */    500,  /*249   */ 556,  /*250   */ 556,  /*251   */ 556,
    /*252   */    556,  /*253   */ 444,  /*254   */ 500,  /*255   */ 444
};

static const int  _WIDTHS_TIMES_ITALIC[256] = {
    /*000   */    250,  /*001   */ 250,  /*002   */ 250,  /*003   */ 250,
    /*004   */    250,  /*005   */ 250,  /*006   */ 250,  /*007   */ 250,
    /*008   */    250,  /*009   */ 250,  /*010   */ 250,  /*011   */ 250,
    /*012   */    250,  /*013   */ 250,  /*014   */ 250,  /*015   */ 250,
    /*016   */    250,  /*017   */ 250,  /*018   */ 250,  /*019   */ 250,
    /*020   */    250,  /*021   */ 250,  /*022   */ 250,  /*023   */ 250,
    /*024   */    250,  /*025   */ 250,  /*026   */ 250,  /*027   */ 250,
    /*028   */    250,  /*029   */ 250,  /*030   */ 250,  /*031   */ 250,
    /*032   */    250,  /*033 ! */ 333,  /*034 " */ 420,  /*035 # */ 500,
    /*036 $ */    500,  /*037 % */ 833,  /*038 & */ 778,  /*039 ' */ 214,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 500,  /*043 + */ 675,
    /*044 , */    250,  /*045 - */ 333,  /*046 . */ 250,  /*047 / */ 278,
    /*048 0 */    500,  /*049 1 */ 500,  /*050 2 */ 500,  /*051 3 */ 500,
    /*052 4 */    500,  /*053 5 */ 500,  /*054 6 */ 500,  /*055 7 */ 500,
    /*056 8 */    500,  /*057 9 */ 500,  /*058 : */ 333,  /*059 ; */ 333,
    /*060 < */    675,  /*061 = */ 675,  /*062 > */ 675,  /*063 ? */ 500,
    /*064 @ */    920,  /*065 A */ 611,  /*066 B */ 611,  /*067 C */ 667,
    /*068 d */    722,  /*069 E */ 611,  /*070 F */ 611,  /*071 G */ 722,
    /*072 h */    722,  /*073 i */ 333,  /*074 J */ 444,  /*075 K */ 667,
    /*076 L */    556,  /*077 M */ 833,  /*078 N */ 667,  /*079 O */ 722,
    /*080 p */    611,  /*081 Q */ 722,  /*082 R */ 611,  /*083 S */ 500,
    /*084 T */    556,  /*085 u */ 722,  /*086 V */ 611,  /*087 W */ 833,
    /*088 X */    611,  /*089 Y */ 556,  /*090 Z */ 556,  /*091 [ */ 389,
    /*092 \ */    278,  /*093 ] */ 389,  /*094 ^ */ 422,  /*095 _ */ 500,
    /*096 \x60 */ 333,  /*097 a */ 500,  /*098 b */ 500,  /*099 c */ 444,
    /*100 d */    500,  /*101 e */ 444,  /*102 f */ 278,  /*103 g */ 500,
    /*104 h */    500,  /*105 i */ 278,  /*106 j */ 278,  /*107 k */ 444,
    /*108 l */    278,  /*109 m */ 722,  /*110 n */ 500,  /*111 o */ 500,
    /*112 p */    500,  /*113 q */ 500,  /*114 r */ 389,  /*115 s */ 389,
    /*116 t */    278,  /*117 u */ 500,  /*118 v */ 444,  /*119 w */ 667,
    /*120 x */    444,  /*121 y */ 444,  /*122 z */ 389,  /*123 { */ 400,
    /*124 | */    275,  /*125 } */ 400,  /*126 ~ */ 541,  /*127   */ 350,
    /*128   */    500,  /*129   */ 350,  /*130   */ 333,  /*131   */ 500,
    /*132   */    556,  /*133   */ 889,  /*134   */ 500,  /*135   */ 500,
    /*136   */    333,  /*137   */ 1000, /*138   */ 500,  /*139   */ 333,
    /*140   */    944,  /*141   */ 350,  /*142   */ 556,  /*143   */ 350,
    /*144   */    350,  /*145   */ 333,  /*146   */ 333,  /*147   */ 556,
    /*148   */    556,  /*149   */ 350,  /*150   */ 500,  /*151   */ 889,
    /*152   */    333,  /*153   */ 980,  /*154   */ 389,  /*155   */ 333,
    /*156   */    667,  /*157   */ 350,  /*158   */ 389,  /*159   */ 556,
    /*160   */    250,  /*161   */ 389,  /*162   */ 500,  /*163   */ 500,
    /*164   */    500,  /*165   */ 500,  /*166   */ 275,  /*167   */ 500,
    /*168   */    333,  /*169   */ 760,  /*170   */ 276,  /*171   */ 500,
    /*172   */    675,  /*173   */ 333,  /*174   */ 760,  /*175   */ 333,
    /*176   */    400,  /*177   */ 675,  /*178   */ 300,  /*179   */ 300,
    /*180   */    333,  /*181   */ 500,  /*182   */ 523,  /*183   */ 250,
    /*184   */    333,  /*185   */ 300,  /*186   */ 310,  /*187   */ 500,
    /*188   */    750,  /*189   */ 750,  /*190   */ 750,  /*191   */ 500,
    /*192   */    611,  /*193   */ 611,  /*194   */ 611,  /*195   */ 611,
    /*196   */    611,  /*197   */ 611,  /*198   */ 889,  /*199   */ 667,
    /*200   */    611,  /*201   */ 611,  /*202   */ 611,  /*203   */ 611,
    /*204   */    333,  /*205   */ 333,  /*206   */ 333,  /*207   */ 333,
    /*208   */    722,  /*209   */ 667,  /*210   */ 722,  /*211   */ 722,
    /*212   */    722,  /*213   */ 722,  /*214   */ 722,  /*215   */ 675,
    /*216   */    722,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 556,  /*222   */ 611,  /*223   */ 500,
    /*224   */    500,  /*225   */ 500,  /*226   */ 500,  /*227   */ 500,
    /*228   */    500,  /*229   */ 500,  /*230   */ 667,  /*231   */ 444,
    /*232   */    444,  /*233   */ 444,  /*234   */ 444,  /*235   */ 444,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    500,  /*241   */ 500,  /*242   */ 500,  /*243   */ 500,
    /*244   */    500,  /*245   */ 500,  /*246   */ 500,  /*247   */ 675,
    /*248   */    500,  /*249   */ 500,  /*250   */ 500,  /*251   */ 500,
    /*252   */    500,  /*253   */ 444,  /*254   */ 500,  /*255   */ 444
};

static const int  _WIDTHS_TIMES_ROMAN[256] = {
    /*000   */    250,  /*001   */ 250,  /*002   */ 250,  /*003   */ 250,
    /*004   */    250,  /*005   */ 250,  /*006   */ 250,  /*007   */ 250,
    /*008   */    250,  /*009   */ 250,  /*010   */ 250,  /*011   */ 250,
    /*012   */    250,  /*013   */ 250,  /*014   */ 250,  /*015   */ 250,
    /*016   */    250,  /*017   */ 250,  /*018   */ 250,  /*019   */ 250,
    /*020   */    250,  /*021   */ 250,  /*022   */ 250,  /*023   */ 250,
    /*024   */    250,  /*025   */ 250,  /*026   */ 250,  /*027   */ 250,
    /*028   */    250,  /*029   */ 250,  /*030   */ 250,  /*031   */ 250,
    /*032   */    250,  /*033 ! */ 333,  /*034 " */ 408,  /*035 # */ 500,
    /*036 $ */    500,  /*037 % */ 833,  /*038 & */ 778,  /*039 ' */ 180,
    /*040 ( */    333,  /*041 ) */ 333,  /*042 * */ 500,  /*043 + */ 564,
    /*044 , */    250,  /*045 - */ 333,  /*046 . */ 250,  /*047 / */ 278,
    /*048 0 */    500,  /*049 1 */ 500,  /*050 2 */ 500,  /*051 3 */ 500,
    /*052 4 */    500,  /*053 5 */ 500,  /*054 6 */ 500,  /*055 7 */ 500,
    /*056 8 */    500,  /*057 9 */ 500,  /*058 : */ 278,  /*059 ; */ 278,
    /*060 < */    564,  /*061 = */ 564,  /*062 > */ 564,  /*063 ? */ 444,
    /*064 @ */    921,  /*065 A */ 722,  /*066 B */ 667,  /*067 C */ 667,
    /*068 d */    722,  /*069 E */ 611,  /*070 F */ 556,  /*071 G */ 722,
    /*072 h */    722,  /*073 i */ 333,  /*074 J */ 389,  /*075 K */ 722,
    /*076 L */    611,  /*077 M */ 889,  /*078 N */ 722,  /*079 O */ 722,
    /*080 p */    556,  /*081 Q */ 722,  /*082 R */ 667,  /*083 S */ 556,
    /*084 T */    611,  /*085 u */ 722,  /*086 V */ 722,  /*087 W */ 944,
    /*088 X */    722,  /*089 Y */ 722,  /*090 Z */ 611,  /*091 [ */ 333,
    /*092 \ */    278,  /*093 ] */ 333,  /*094 ^ */ 469,  /*095 _ */ 500,
    /*096 \x60 */ 333,  /*097 a */ 444,  /*098 b */ 500,  /*099 c */ 444,
    /*100 d */    500,  /*101 e */ 444,  /*102 f */ 333,  /*103 g */ 500,
    /*104 h */    500,  /*105 i */ 278,  /*106 j */ 278,  /*107 k */ 500,
    /*108 l */    278,  /*109 m */ 778,  /*110 n */ 500,  /*111 o */ 500,
    /*112 p */    500,  /*113 q */ 500,  /*114 r */ 333,  /*115 s */ 389,
    /*116 t */    278,  /*117 u */ 500,  /*118 v */ 500,  /*119 w */ 722,
    /*120 x */    500,  /*121 y */ 500,  /*122 z */ 444,  /*123 { */ 480,
    /*124 | */    200,  /*125 } */ 480,  /*126 ~ */ 541,  /*127   */ 350,
    /*128   */    500,  /*129   */ 350,  /*130   */ 333,  /*131   */ 500,
    /*132   */    444,  /*133   */ 1000, /*134   */ 500,  /*135   */ 500,
    /*136   */    333,  /*137   */ 1000, /*138   */ 556,  /*139   */ 333,
    /*140   */    889,  /*141   */ 350,  /*142   */ 611,  /*143   */ 350,
    /*144   */    350,  /*145   */ 333,  /*146   */ 333,  /*147   */ 444,
    /*148   */    444,  /*149   */ 350,  /*150   */ 500,  /*151   */ 1000,
    /*152   */    333,  /*153   */ 980,  /*154   */ 389,  /*155   */ 333,
    /*156   */    722,  /*157   */ 350,  /*158   */ 444,  /*159   */ 722,
    /*160   */    250,  /*161   */ 333,  /*162   */ 500,  /*163   */ 500,
    /*164   */    500,  /*165   */ 500,  /*166   */ 200,  /*167   */ 500,
    /*168   */    333,  /*169   */ 760,  /*170   */ 276,  /*171   */ 500,
    /*172   */    564,  /*173   */ 333,  /*174   */ 760,  /*175   */ 333,
    /*176   */    400,  /*177   */ 564,  /*178   */ 300,  /*179   */ 300,
    /*180   */    333,  /*181   */ 500,  /*182   */ 453,  /*183   */ 250,
    /*184   */    333,  /*185   */ 300,  /*186   */ 310,  /*187   */ 500,
    /*188   */    750,  /*189   */ 750,  /*190   */ 750,  /*191   */ 444,
    /*192   */    722,  /*193   */ 722,  /*194   */ 722,  /*195   */ 722,
    /*196   */    722,  /*197   */ 722,  /*198   */ 889,  /*199   */ 667,
    /*200   */    611,  /*201   */ 611,  /*202   */ 611,  /*203   */ 611,
    /*204   */    333,  /*205   */ 333,  /*206   */ 333,  /*207   */ 333,
    /*208   */    722,  /*209   */ 722,  /*210   */ 722,  /*211   */ 722,
    /*212   */    722,  /*213   */ 722,  /*214   */ 722,  /*215   */ 564,
    /*216   */    722,  /*217   */ 722,  /*218   */ 722,  /*219   */ 722,
    /*220   */    722,  /*221   */ 722,  /*222   */ 556,  /*223   */ 500,
    /*224   */    444,  /*225   */ 444,  /*226   */ 444,  /*227   */ 444,
    /*228   */    444,  /*229   */ 444,  /*230   */ 667,  /*231   */ 444,
    /*232   */    444,  /*233   */ 444,  /*234   */ 444,  /*235   */ 444,
    /*236   */    278,  /*237   */ 278,  /*238   */ 278,  /*239   */ 278,
    /*240   */    500,  /*241   */ 500,  /*242   */ 500,  /*243   */ 500,
    /*244   */    500,  /*245   */ 500,  /*246   */ 500,  /*247   */ 564,
    /*248   */    500,  /*249   */ 500,  /*250   */ 500,  /*251   */ 500,
    /*252   */    500,  /*253   */ 500,  /*254   */ 500,  /*255   */ 500
};

static const int  _WIDTHS_ZAPF_DINGBATS[256] = {
    /*000   */    0,    /*001   */ 0,    /*002   */ 0,    /*003   */ 0,
    /*004   */    0,    /*005   */ 0,    /*006   */ 0,    /*007   */ 0,
    /*008   */    0,    /*009   */ 0,    /*010   */ 0,    /*011   */ 0,
    /*012   */    0,    /*013   */ 0,    /*014   */ 0,    /*015   */ 0,
    /*016   */    0,    /*017   */ 0,    /*018   */ 0,    /*019   */ 0,
    /*020   */    0,    /*021   */ 0,    /*022   */ 0,    /*023   */ 0,
    /*024   */    0,    /*025   */ 0,    /*026   */ 0,    /*027   */ 0,
    /*028   */    0,    /*029   */ 0,    /*030   */ 0,    /*031   */ 0,
    /*032   */    278,  /*033 ! */ 974,  /*034 " */ 961,  /*035 # */ 974,
    /*036 $ */    980,  /*037 % */ 719,  /*038 & */ 789,  /*039 ' */ 790,
    /*040 ( */    791,  /*041 ) */ 690,  /*042 * */ 960,  /*043 + */ 939,
    /*044 , */    549,  /*045 - */ 855,  /*046 . */ 911,  /*047 / */ 933,
    /*048 0 */    911,  /*049 1 */ 945,  /*050 2 */ 974,  /*051 3 */ 755,
    /*052 4 */    846,  /*053 5 */ 762,  /*054 6 */ 761,  /*055 7 */ 571,
    /*056 8 */    677,  /*057 9 */ 763,  /*058 : */ 760,  /*059 ; */ 759,
    /*060 < */    754,  /*061 = */ 494,  /*062 > */ 552,  /*063 ? */ 537,
    /*064 @ */    577,  /*065 A */ 692,  /*066 B */ 786,  /*067 C */ 788,
    /*068 d */    788,  /*069 E */ 790,  /*070 F */ 793,  /*071 G */ 794,
    /*072 h */    816,  /*073 i */ 823,  /*074 J */ 789,  /*075 K */ 841,
    /*076 L */    823,  /*077 M */ 833,  /*078 N */ 816,  /*079 O */ 831,
    /*080 p */    923,  /*081 Q */ 744,  /*082 R */ 723,  /*083 S */ 749,
    /*084 T */    790,  /*085 u */ 792,  /*086 V */ 695,  /*087 W */ 776,
    /*088 X */    768,  /*089 Y */ 792,  /*090 Z */ 759,  /*091 [ */ 707,
    /*092 \ */    708,  /*093 ] */ 682,  /*094 ^ */ 701,  /*095 _ */ 826,
    /*096 \x60 */ 815,  /*097 a */ 789,  /*098 b */ 789,  /*099 c */ 707,
    /*100 d */    687,  /*101 e */ 696,  /*102 f */ 689,  /*103 g */ 786,
    /*104 h */    787,  /*105 i */ 713,  /*106 j */ 791,  /*107 k */ 785,
    /*108 l */    791,  /*109 m */ 873,  /*110 n */ 761,  /*111 o */ 762,
    /*112 p */    762,  /*113 q */ 759,  /*114 r */ 759,  /*115 s */ 892,
    /*116 t */    892,  /*117 u */ 788,  /*118 v */ 784,  /*119 w */ 438,
    /*120 x */    138,  /*121 y */ 277,  /*122 z */ 415,  /*123 { */ 392,
    /*124 | */    392,  /*125 } */ 668,  /*126 ~ */ 668,  /*127   */ 0,
    /*128   */    390,  /*129   */ 390,  /*130   */ 317,  /*131   */ 317,
    /*132   */    276,  /*133   */ 276,  /*134   */ 509,  /*135   */ 509,
    /*136   */    410,  /*137   */ 410,  /*138   */ 234,  /*139   */ 234,
    /*140   */    334,  /*141   */ 334,  /*142   */ 0,    /*143   */ 0,
    /*144   */    0,    /*145   */ 0,    /*146   */ 0,    /*147   */ 0,
    /*148   */    0,    /*149   */ 0,    /*150   */ 0,    /*151   */ 0,
    /*152   */    0,    /*153   */ 0,    /*154   */ 0,    /*155   */ 0,
    /*156   */    0,    /*157   */ 0,    /*158   */ 0,    /*159   */ 0,
    /*160   */    0,    /*161   */ 732,  /*162   */ 544,  /*163   */ 544,
    /*164   */    910,  /*165   */ 667,  /*166   */ 760,  /*167   */ 760,
    /*168   */    776,  /*169   */ 595,  /*170   */ 694,  /*171   */ 626,
    /*172   */    788,  /*173   */ 788,  /*174   */ 788,  /*175   */ 788,
    /*176   */    788,  /*177   */ 788,  /*178   */ 788,  /*179   */ 788,
    /*180   */    788,  /*181   */ 788,  /*182   */ 788,  /*183   */ 788,
    /*184   */    788,  /*185   */ 788,  /*186   */ 788,  /*187   */ 788,
    /*188   */    788,  /*189   */ 788,  /*190   */ 788,  /*191   */ 788,
    /*192   */    788,  /*193   */ 788,  /*194   */ 788,  /*195   */ 788,
    /*196   */    788,  /*197   */ 788,  /*198   */ 788,  /*199   */ 788,
    /*200   */    788,  /*201   */ 788,  /*202   */ 788,  /*203   */ 788,
    /*204   */    788,  /*205   */ 788,  /*206   */ 788,  /*207   */ 788,
    /*208   */    788,  /*209   */ 788,  /*210   */ 788,  /*211   */ 788,
    /*212   */    894,  /*213   */ 838,  /*214   */ 1016, /*215   */ 458,
    /*216   */    748,  /*217   */ 924,  /*218   */ 748,  /*219   */ 918,
    /*220   */    927,  /*221   */ 928,  /*222   */ 928,  /*223   */ 834,
    /*224   */    873,  /*225   */ 828,  /*226   */ 924,  /*227   */ 924,
    /*228   */    917,  /*229   */ 930,  /*230   */ 931,  /*231   */ 463,
    /*232   */    883,  /*233   */ 836,  /*234   */ 836,  /*235   */ 867,
    /*236   */    867,  /*237   */ 696,  /*238   */ 696,  /*239   */ 874,
    /*240   */    0,    /*241   */ 874,  /*242   */ 760,  /*243   */ 946,
    /*244   */    771,  /*245   */ 865,  /*246   */ 771,  /*247   */ 888,
    /*248   */    967,  /*249   */ 888,  /*250   */ 831,  /*251   */ 873,
    /*252   */    927,  /*253   */ 970,  /*254   */ 918,  /*255   */ 000
};

/* array of standard page sizes */
static const _page_size_t  _STANDARD_PAGE_SIZES[10] = {
    { "a3",       841.89, 1190.55 },
    { "a3-l",    1190.55,  841.89 },
    { "a4",       595.28,  841.89 },
    { "a4-l",     841.89,  595.28 },
    { "a5",       420.94,  595.28 },
    { "a5-l",     595.28,  420.94 },
    { "legal",       612,    1008 },
    { "legal-l",    1008,     612 },
    { "letter",      612,     792 },
    { "letter-l",    792,     612 }
};


/* -------------------------------------------------------------------------- */
/* Methods: Private                                                           */


#if defined __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#endif

#define _BASE_OBJ_WRAP_INC
#define _OBJ_HANDLE_TYPE   pdf_t
#define _OBJ_INNER_TYPE    _pdf_t
#define _OBJ_ALLOC_FN_UID  UID(F4EE90)
#define _OBJ_FREE_FN_UID   UID(FB454A)
#define _OBJ_CONST_FN_UID  UID(F6DA3A)
#define _OBJ_FN_UID        UID(FA70C5)
#define _OBJ_WRAP_FN_UID   UID(F3C86C)
#include "libex_object_wrapper.inc.c"


/* TODO: find a better location for this? */
static void  _set_lowercase_ascii( char*  string_ ) {                      /*F*/
    if (string_ != NULL) {
        while (*string_ != '\0') {
            if (*string_ >= 'A' && *string_ <= 'Z') {
                *string_ |= 0x20;
            }
            string_++;
        }
    }
} /* _set_lowercase_ascii */


#define _array_add_item( TYPE_, ARRAY_ )                                  /*F*/\
    CAST(TYPE_*, _array_add_item_fn(&ARRAY_, sizeof(TYPE_)))               /*#*/


static uint8_t*  _array_add_item_fn(                                       /*F*/
    _array_t*     array_,                                                  /*-*/
    const size_t  item_size_in_bytes_ ) {                                  /*-*/
    GO                                                            (UID(FB7570));
    array_->count++;

    if (array_ == NULL) {
        RETURN(NULL);

    } else if (array_->count > array_->cap) {
        uint8_t*  moved = NULL;

        size_t  new_cap = CAST(size_t, CAST(double, array_->count) * 1.5);
        if (new_cap < array_->cap + 10) {
            new_cap = array_->cap + 10;
        }

        moved = CAST(uint8_t*, REALLOC(array_->data,
                                       new_cap * item_size_in_bytes_));
        array_->cap  = new_cap;
        array_->data = moved;
    }

    {
        /* return pointer to added item */
        uint8_t*  ret = array_->data
                        + (item_size_in_bytes_ * (array_->count - 1));
        MEMSET(ret, 0x00, item_size_in_bytes_);
        RETURN(ret);
    }
} /* _array_add_item_fn */


#define _array_get_item( TYPE_, ARRAY_, INDEX_ )                          /*F*/\
    CAST(TYPE_*, _array_get_item_fn(&ARRAY_, sizeof(TYPE_), INDEX_))       /*#*/


static uint8_t*  _array_get_item_fn(                                       /*F*/
    _array_t*       array_,                                                /*-*/
    const size_t    item_size_in_bytes_,                                   /*-*/
    const uint32_t  index_ ) {                                             /*-*/
    GO                                                            (UID(F14BC9));
    if (array_ == NULL) {
        WARN("array_ == NULL", UID(E2394D));
        RETURN(NULL);
    }

    if (index_ > (array_->count + 1)) {
        WARN("index_ out of range.", UID(E2B00D));
    }

    while (index_ >= array_->count) {
        _array_add_item_fn(array_, item_size_in_bytes_);
    }

    {
        uint8_t*  ret = array_->data + item_size_in_bytes_ * index_;
        RETURN(ret);
    }
} /* _array_get_item_fn */


#define _array_init( ARRAY_ )                                             /*F*/\
    ARRAY_.cap   = 0;                                                          \
    ARRAY_.count = 0;                                                          \
    ARRAY_.data  = NULL                                                    /*#*/


static int  _print_obj( _pdf_t*, const char*);                           /*F*D*/
static int  _print_stream( _pdf_t*, const char*);                        /*F*D*/
static void  _printf( _pdf_t*, const char*, ... );                       /*F*D*/
static void  _set_curr_page( _pdf_t*, const uint32_t );                  /*F*D*/
static new_bchars_t  _pack_text( const char*, bool*);                    /*F*D*/

#if defined UNICODE || defined _UNICODE
static new_bchars_t  _utf8_from_wide( const wchar_t*);                   /*F*D*/
#endif

static void  _compose_pdf( _pdf_t*  me_ ) {                                /*F*/
    GO                                                            (UID(FA1552));
    const uint32_t  page_objects_index = 3;
    const uint32_t  font_objects_index =
        page_objects_index + me_->pages.count * 2;

    const uint32_t  info_object_index =
        font_objects_index + me_->fonts.count;

    uint32_t  i = 0;

    _set_curr_page(me_, NONE);

    /* free any existing pdf content */
    freeA(&me_->content.chars);
    CLEAR(me_->content);

    /* write beginning of document: */
    _printf(       me_, "%%PDF-1.4" "\n");
    _print_obj (   me_, "/Catalog");  /* 1 0 obj */
    _printf(       me_, "/Pages 2 0 R");
    _print_endobj( me_);

    {
        /* write /Pages object: */
        _print_obj(me_, "/Pages");  /* 2 0 obj */

        /* write page count and page size */
        _printf(me_, "/Count %d/MediaBox[0 0 %d %d]",
                CAST(int, me_->pages.count),
                CAST(int, me_->page_size.width_pt),
                CAST(int, me_->page_size.height_pt));

        /* write list of page numbers */
        if (me_->pages.count > 0) {
            size_t  page_object_no = page_objects_index;
            _printf(me_, "/Kids[");

            for (i = 0; i < me_->pages.count; i++) {
                _printf(me_, i == 0 ? "%d 0 R" : " %d 0 R",
                        CAST(int, page_object_no));
                page_object_no += 2;  /* 1 for page, 1 for stream */
            }
            _printf(me_, "]");
        }
        _print_endobj(me_);
    }

    /* write each page */
    for (i = 0; i < me_->pages.count; i++) {
        _page_t*  page = _array_get_item(_page_t, me_->pages, i);

        if (page->page_content.chars != NULL) {
            _print_obj(me_, "/Page");

            _printf(me_, "/Parent 2 0 R/Contents %d 0 R",
                    CAST(int, me_->object_no + 1));

            if (page->font_ids.count > 0) {
                uint32_t  font = 0;
                _printf(me_, "/Resources <</Font <<");

                for (font = 0; font < me_->fonts.count; font++) {
                    _printf(me_, "/F%d %d 0 R ",
                            CAST(int, font + 1),
                            CAST(int, font_objects_index + font));
                }

                _printf(me_, ">> >>");
            }

            _print_endobj(me_);
            _print_stream(me_, page->page_content.chars);
        } else {
            WARN(_T("empty page"), UID(E4F5FB));
        }
    }

    /* write fonts */
    for (i = 0; i < me_->fonts.count; i++) {
        _font_type_t*  item = _array_get_item(_font_type_t, me_->fonts, i);
        _print_obj(me_, "/Font");

        if (item->standard) {
#if defined UNICODE || defined _UNICODE
            char*  font_name = _utf8_from_wide(item->font_name);
#else                                                  /* UNICODE || _UNICODE */
            char*  font_name = item->font_name;
#endif                                               /* !UNICODE && !_UNICODE */
            _printf(me_, "/Subtype/Type1/Name/F%d"
                    "/BaseFont/%s/Encoding/WinAnsiEncoding",
                    CAST(int,         item->font_id),
                    CAST(const char*, font_name));

#if defined UNICODE || defined _UNICODE
            freeA(&font_name);
#endif
        }

        _print_endobj(me_);
    }

    /* write info object */
    if (me_->doc_title    != NULL  ||
        me_->doc_subject  != NULL  ||
        me_->doc_keywords != NULL  ||
        me_->doc_author   != NULL  ||
        me_->doc_creator  != NULL) {

#if defined UNICODE || defined _UNICODE
        new_bchars_t  doc_title    = _utf8_from_wide(me_->doc_title);
        new_bchars_t  doc_subject  = _utf8_from_wide(me_->doc_subject);
        new_bchars_t  doc_keywords = _utf8_from_wide(me_->doc_keywords);
        new_bchars_t  doc_author   = _utf8_from_wide(me_->doc_author);
        new_bchars_t  doc_creator  = _utf8_from_wide(me_->doc_creator);
#else
        char*  doc_title    = me_->doc_title;
        char*  doc_subject  = me_->doc_subject;
        char*  doc_keywords = me_->doc_keywords;
        char*  doc_author   = me_->doc_author;
        char*  doc_creator  = me_->doc_creator;
#endif                                               /* !UNICODE && !_UNICODE */
        typedef struct  _info_field_t {
            const char*    label;                            /* _info_field_t */
            new_bchars_t*  field;                            /* _info_field_t */
        }
        _info_field_t;

        _info_field_t  fields[5];
        fields[0].label = "/Title ";
        fields[0].field = &doc_title;
        fields[1].label = "/Subject ";
        fields[1].field = &doc_subject;
        fields[2].label = "/Keywords ";
        fields[2].field = &doc_keywords;
        fields[3].label = "/Author ";
        fields[3].field = &doc_author;
        fields[4].label = "/Creator ";
        fields[4].field = &doc_creator;

        {
            const uint32_t  index = _print_obj(me_, "");
            ASSERT(index == info_object_index, UID(EC33E1));
        }

        for (i = 0; i < 5; i++) {
            if (*fields[i].field != NULL) {

                bool  need_to_free = false;

                new_bchars_t  val =
                    _pack_text(*fields[i].field, &need_to_free);

                _printf(me_, fields[i].label);
                _printf(me_, "(");
                _printf(me_, val);
                _printf(me_, ")");

                if (need_to_free) {
                    freeA(&val);
                }
            }
        }

#if defined UNICODE || defined _UNICODE
        freeA(&doc_title);
        freeA(&doc_subject);
        freeA(&doc_keywords);
        freeA(&doc_author);
        freeA(&doc_creator);
#endif                                                 /* UNICODE || _UNICODE */
        _print_endobj(me_);  /* info */
    }

    {
        /* write ending of document: */
        const size_t  start_xref = me_->content.len;

        _set_curr_page(me_, NONE);

        /* write the object cross-reference */
        _printf(me_,
                "xref" "\n"
                "0 %d" "\n"
                "0000000000 65535 f " "\n",
                CAST(int, me_->object_offsets.count));

        for (i = 1; i < me_->object_offsets.count; i++) {
            size_t*  offset = _array_get_item(size_t, me_->object_offsets, i);

            _printf(me_, "%010d 00000 n " "\n", CAST(int, *offset));
        }

        {
            /* write the trailer */
            _printf(me_, "trailer"  "\n"  "<</Size %d/Root 1 0 R",
                    CAST(int, me_->object_offsets.count));

            if (info_object_index > 0) {
                _printf(me_,
                        "/Info %d 0 R", CAST(int, info_object_index));
            }

            _printf(me_, ">>" "\n"  "startxref" "\n"  "%d" "\n",
                    CAST(int, start_xref));
        }
        _printf(me_, "%%%%EOF" "\n");
    }
    RETURN(NIL);
} /* _compose_pdf */


static int  _next_object( _pdf_t*  me_ ) {                                 /*F*/
    GO                                                            (UID(F37203));
    size_t*  offset = NULL;

    /* increase object serial number */
    me_->object_no++;

    /* store object's offset in the offsets array */
    while (me_->object_offsets.count <= me_->object_no) {
        offset = _array_add_item(size_t, me_->object_offsets);
        *offset = 0;
    }

    offset  = _array_get_item(size_t, me_->object_offsets, me_->object_no);
    *offset = me_->content.len;
    {
        const int  ret = me_->object_no;
        RETURN(ret);
    }
} /* _next_object */


static new_bchars_t  _pack_text(                                           /*F*/
    const char*  text_,                                                    /*-*/
    bool*        need_to_free_out_ ) {                                     /*-*/
    GO                                                            (UID(FBE22F));
    const bool  escape = C_BOOL((STRCHR(text_, '(') ||
                                 STRCHR(text_, ')') ||
                                 STRCHR(text_, '\\')));

    new_bchars_t  ret = NULL;
    const size_t   len = (!text_ ? 0 : STRLEN(text_));

    if (escape) {
        const char*  rd = text_;
        char*        wr = ret = CAST(char*, MALLOC((len + 1) * 2));

        while (*rd) {
            if (*rd == '(' || *rd == ')' || *rd == '\\') {
                *wr++ = '\\';;
            }
            *wr++ = *rd++;
        }
        *wr = '\0';
    } else {
        ret = CAST(new_bchars_t, text_);
    }

    *need_to_free_out_ = escape;
    RETURN(ret);
} /* _pack_text */


static int  _print_obj(                                                    /*F*/
    _pdf_t*      me_,                                                      /*-*/
    const char*  object_type_ ) {                                          /*-*/
    GO                                                            (UID(FB22D3));
    int  object_no = 0;

    _set_curr_page(me_, NONE);
    object_no = _next_object(me_);

    if (object_type_ == NULL ||
        (object_type_[0] != '/' && object_type_[0] != '\0')) {

        WARN("object_type_ should begin with '/' or be a blank string.",
             UID(EA16AB));
        RETURN(0);
    }

    _printf(me_, object_type_[0] == '/' ? "%d 0 obj<</Type%s" : "%d 0 obj<<",
            CAST(int, object_no), CAST(char*, object_type_));

    RETURN(object_no);
} /* _print_obj */


static void  _str_reserve( _string_t*, const size_t );                   /*F*D*/


static int  _print_stream(                                                 /*F*/
    _pdf_t*      me_,                                                      /*-*/
    const char*  content_ ) {                                              /*-*/
    GO                                                            (UID(F13169));
    const int     object_no  = _next_object(me_);
    const size_t  stream_len = (!content_ ? 0 : STRLEN(content_));

    _set_curr_page(me_, NONE);

#if defined PDF_ZLIB_COMPRESSION

    if (me_->compress_streams) {
        uLongf    comp_size = compressBound(stream_len);
        uint8_t*  comp_buf  = CAST(uint8_t*, MALLOC(comp_size));

        /* compress data to the temporary buffer */
        const int  result = compress2(
                                comp_buf,                       /* *dest      */
                                &comp_size,                     /* *destLen   */
                                CAST(const Bytef*, content_),   /* *source    */
                                stream_len,                     /* sourceLen* */
                                Z_BEST_COMPRESSION);            /* level      */
        if (result != Z_OK) {
#if defined __GNUC__ && !defined __clang__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif
            chars_t  err = NULL;
            switch (result) {
                    CASE_TO_TEXT(Z_BUF_ERROR,    err);
                    CASE_TO_TEXT(Z_MEM_ERROR,    err);
                    CASE_TO_TEXT(Z_STREAM_ERROR, err);
                default:
                    err = _T("<other error>");
            }
            WARN(err, UID(E0B47C));

#if defined __GNUC__ && !defined __clang__
#pragma GCC diagnostic pop
#endif
        } else {
            _string_t*  str  = me_->content_ref;
            size_t       free = 0;

            _printf(me_,
                    "%d 0 obj <</Filter/FlateDecode/Length %d>>stream" "\n",
                    CAST(int,   object_no),
                    CAST(int,   comp_size),
                    CAST(char*, comp_buf));

            /* ensure there is enough space to write compressed stream */
            free = str->cap - str->len;

            while (free < comp_size) {
                const size_t  new_size =
                    (str->chars == NULL)
                    ? KB(256)
                    : CAST(size_t, CAST(double, str->cap) * 1.5);

                _str_reserve(str, new_size);
                free = str->cap - str->len;
            }

            /* copy compressed stream to pdf content */
            MEMCPY(CAST(uint8_t*, str->chars) + str->len,
                   comp_buf,
                   comp_size);
            str->len += comp_size;

            _printf(me_, "\n" "endstream" "\n");
        }
        FREE(comp_buf);
    } else
#endif                                                /* PDF_ZLIB_COMPRESSION */
    {
        _printf(me_, "%d 0 obj <</Length %d>>stream\n%s\nendstream\n",
                CAST(int,   object_no),
                CAST(int,   stream_len),
                CAST(char*, content_));
    }
    RETURN(object_no);
} /* _print_stream */


static void  _printf(                                                      /*F*/
    _pdf_t*      me_,                                                      /*-*/
    const char*  format_,                                                  /*-*/
    ... ) {                                                                /*-*/
    GO                                                            (UID(FC2E20));
    _string_t*  str  = NULL;
    int         writ = -1;

    if (me_->page_no == NONE) {
        str = me_->content_ref;

    } else if (me_->page_no > (me_->pages.count - 1)) {
        WARN(_T("Invalid page number."), UID(E54BB7));
    } else {
        str = &me_->page->page_content;
    }

    /* repeat loop until success... */
    while (writ == -1) {
        char*  wr = str->chars + str->len;

        /* attempt writing formatted string */
        va_list  args;
        va_start(args, format_);
        {
            const size_t  free = str->cap - str->len;

            if (free < 1) {
                writ = -1;
            } else {
#if PLATFORM_LINUX
                writ = vsnprintf(wr, free, format_, args);
#endif

#if PLATFORM_WIN32
                writ = VSNPRINTF_S(wr, free, _TRUNCATE, format_, args);
#endif
            }
        }
        va_end(args);

        /* if string is too small, grow its capacity by 50% */
        if (writ == -1) {
            const size_t  new_size =
                (str->chars == NULL) ? KB(256)
                : CAST(size_t, CAST(double, str->cap) * 1.5);

            _str_reserve(str, new_size);
        } else {
            str->len += writ;
        }
    }
    RETURN(NIL);
} /* _printf */


#define _set_char_array(     CHAR_ARRAY_, TEXT_ )                         /*F*/\
    _set_char_array_internal(CHAR_ARRAY_, sizeof(CHAR_ARRAY_), TEXT_)      /*#*/

static void  _set_char_array_internal(                                     /*F*/
    char_t*       char_array_,                                             /*-*/
    const size_t  size_of_array_,                                          /*-*/
    chars_t       text_ ) {                                                /*-*/
    GO                                                            (UID(F0A64B));
    const size_t  chars = size_of_array_ / sizeof(char_t);
    MEMSET(char_array_, 0x00, size_of_array_);
    STRCPY_S_T(char_array_, chars, text_);
    RETURN(NIL);
} /* _set_char_array_internal */


static void  _set_curr_page(                                               /*F*/
    _pdf_t*         me_,                                                   /*-*/
    const uint32_t  page_no_ ) {                                           /*-*/
    GO                                                            (UID(F4ED89));
    if (page_no_ != NONE && page_no_ > (me_->pages.count - 1)) {
        WARN(_T("Page number out of range."), UID(E5B820));

    } else if (page_no_ == NONE) {
        me_->page = NULL;
        me_->content_ref = &me_->content;

    } else {
        me_->page = _array_get_item(_page_t, me_->pages, page_no_);
        me_->content_ref = &me_->page->page_content;
    }
    me_->page_no = page_no_;
    RETURN(NIL);
} /* _set_curr_page */


static bool  _set_font( _pdf_t*  me_ ) {                                   /*F*/
    GO                                                            (UID(FC5792));
    /*  This should be called just before a font needs to be used,    */
    /*  mainly the text() method. This way, if a font is picked with  */
    /*  setFontNamePdf() property, but never used to draw text,       */
    /*  no font selection command is output.                          */
    /*                                                                */
    /*  Before calling this subroutine, the font name must be         */
    /*  already set by setFontNamePdf(), which is stored in           */
    /*  me_->font.font_name                                           */
    /*                                                                */
    /*  What this subroutine does:                                    */
    /*                                                                */
    /*  - It validates the current font name and determines           */
    /*    if it is a standard (built-in) font like Helvetica          */
    /*    or a TrueType font.                                         */
    /*                                                                */
    /*  - It fills the document-wide list of fonts (me_->fonts).      */
    /*                                                                */
    /*  - It adds items to the list of font ID's                      */
    /*    used on the current page.                                   */
    /*                                                                */
    /*  - It returns true if the font name is valid,                  */
    /*    or false otherwise.                                         */

    uint32_t       i    = 0;
    _font_type_t*  font = &me_->font;

    bool  font_valid = C_BOOL(STRLEN_T(font->font_name) > 0);

    if (me_->page->font_id == me_->font.font_id &&
        (CAST(int, me_->page->font_size_pt * 100)
         == CAST(int, me_->font_size_pt) * 100)) {
        RETURN(true);
    }

    if (font_valid) {
        font->standard = false;
        font_valid     = false;

        for (i = 0; i < 14; i++) {
            if (STRICMP_T(font->font_name, _STD_FONT_NAMES[i]) == 0) {
                font->standard = true;
                font_valid     = true;
                font->is_bold  =
                    C_BOOL(strstriT(font->font_name, _T("Bold")));
                font->italic   =
                    C_BOOL((strstriT(font->font_name, _T("Oblique"))) ||
                           (strstriT(font->font_name, _T("Italic"))));
                break;
            }
        }
    }

    /* if there is no selected font or it's invalid, use Helvetica */
    if (!font_valid) {
        _set_char_array(font->font_name, _T("Helvetica"));
        font->standard = true;
        font_valid     = true;
    }

    /* has the font been added to the global list? If not, add it. */
    font->font_id = NONE;

    for (i = 0; i < me_->fonts.count; i++) {
        _font_type_t*  item = _array_get_item(_font_type_t, me_->fonts, i);
        if (STRICMP_T(font->font_name, item->font_name) == 0) {
            font->font_id = item->font_id;
        }
    }

    if (font->font_id == NONE) {
        _font_type_t*  item = _array_add_item(_font_type_t, me_->fonts);
        font->font_id = me_->fonts.count;

        _set_char_array(item->font_name, font->font_name);

        item->font_id  = font->font_id;
        item->standard = font->standard;
        item->is_bold  = font->is_bold;
        item->italic   = font->italic;
    }

    {
        /* add the font ID to the current page, if not already referenced */
        bool  already_used_on_page = false;

        for (i = 1; i < me_->page->font_ids.count; i++) {
            const uint32_t*  font_id_used_on_page =
                _array_get_item(uint32_t, me_->page->font_ids, i);

            if (*font_id_used_on_page == font->font_id) {
                already_used_on_page = true;
                break;
            }
        }

        if (!already_used_on_page) {
            uint32_t*  font_id =
                _array_add_item(uint32_t, me_->page->font_ids);
            *font_id = font->font_id;
        }
    }

    me_->page->font_id      = me_->font.font_id;
    me_->page->font_size_pt = me_->font_size_pt;
    _printf(me_, "BT /F%d %d Tf ET" "\n",
            CAST(int, me_->page->font_id),
            CAST(int, me_->page->font_size_pt));

    RETURN(true);
} /* _set_font */


static bool  _set_horizontal_scaling( _pdf_t*  me_ ) {                     /*F*/
    GO                                                            (UID(FACD46));
    if (me_->page->horizontal_scaling != me_->horizontal_scaling) {
        me_->page->horizontal_scaling =  me_->horizontal_scaling;

        _printf(me_, "BT %d Tz ET" "\n",
                CAST(int, me_->page->horizontal_scaling));
    }
    RETURN(true);
} /* _set_horizontal_scaling */


static void  _set_line_width( _pdf_t*  me_ ) {                             /*F*/
    GO                                                            (UID(FBFEEC));
    if (CAST(int, me_->page->line_width * 10000) !=
        CAST(int, me_->line_width       * 10000)) {

        me_->page->line_width = me_->line_width;
        _printf(me_, "%.3f w" "\n", CAST(double, me_->page->line_width));
    }
    RETURN(NIL);
} /* _set_line_width */


static void  _set_non_stroke_color( _pdf_t*  me_ ) {                       /*F*/
    GO                                                            (UID(F57A2B));
    if (!_color_equal(me_->page->color_non_stroke, me_->color)) {
        me_->page->color_non_stroke = me_->color;
        _printf(me_,
                "%.3f %.3f %.3f rg" "\n",  /* non-stroking (text) color */
                CAST(double, me_->page->color_non_stroke.red)   / 255,
                CAST(double, me_->page->color_non_stroke.green) / 255,
                CAST(double, me_->page->color_non_stroke.blue)  / 255);
    }
    RETURN(NIL);
} /* _set_non_stroke_color */


static void  _set_stroke_color( _pdf_t*  me_ ) {                           /*F*/
    GO                                                            (UID(F19A84));
    if (!_color_equal(me_->page->color_stroke, me_->color)) {
        me_->page->color_stroke = me_->color;
        _printf(
            me_,
            "%.3f %.3f %.3f RG" "\n",   /* RG - stroke (line) color */
            CAST(double, me_->page->color_stroke.red)   / 255,
            CAST(double, me_->page->color_stroke.green) / 255,
            CAST(double, me_->page->color_stroke.blue)  / 255);
    }
    RETURN(NIL);
} /* _set_stroke_color */


static void  _store_info_field(                                            /*F*/
    chars_t       info_,                                                   /*-*/
    new_chars_t*  field_ ) {                                               /*-*/
    GO                                                            (UID(FAB653));
    const size_t  len = (!info_ ? 0 : STRLEN_T(info_));

    /* release existing allocation */
    if (*field_ != NULL) {
        FREE(*field_);
        *field_ = NULL;
    }

    /* allocate and copy string */
    if (len > 0) {
        new_chars_t  str = CAST(new_chars_t,
                                MALLOC((len + 1) * sizeof(char_t)));
        STRCPY_S_T(str, len + 1, info_);
        *field_ = str;
    }
    RETURN(NIL);
} /* _store_info_field */


static void  _str_reserve(                                                 /*F*/
    _string_t*    object_,                                                 /*-*/
    const size_t  size_in_bytes_ ) {                                       /*-*/
    GO                                                            (UID(F22014));
    /* increase buffer size if more space is needed (sizes are in bytes) */
    if (object_->cap < size_in_bytes_) {
        char*  str = CAST(char*, REALLOC(object_->chars, size_in_bytes_));
        if (str == NULL) {
            WARN(_T("Memory realloc. failed"), UID(E3517E));
            RETURN(NIL);
        }

        object_->cap   = size_in_bytes_;
        object_->chars = str;

        {
            /* erase unused part: */
            const size_t  clear_bytes = object_->cap - object_->len;
            if (object_->chars && clear_bytes > 0) {
                MEMSET(object_->chars + object_->len, 0x00, clear_bytes);
            }
        }
    }
    RETURN(NIL);
} /* _str_reserve */


#if defined UNICODE || defined _UNICODE
static new_bchars_t  _utf8_from_wide( const wchar_t*  string_ ) {          /*F*/
    GO                                                            (UID(FE7599));
    /* note: if you modify this function, also check and update: */
    /* function utf8_of_wide() in libex_string_class.c                 */

    char*  ret = NULL;

#if PLATFORM_LINUX
    const size_t  len       = WCSLEN(string_);
    const size_t  utf8_size = (len + 1) * sizeof(char);
    mbstate_t     state;

    CLEAR(state);

    ret = MALLOC(utf8_size);
    MEMSET(ret, 0x00, utf8_size);
    WCSRTOMBS(ret, &string_, len, &state);

    RETURN(ret);
#endif                                                      /* PLATFORM_LINUX */

#if PLATFORM_WIN32
    int  dest_len = 0;

    if (string_ == NULL) {
        RETURN(NULL);
    }

    /* determine number of bytes needed for output buffer */
    dest_len = WideCharToMultiByte_win(
                   CP_UTF8_win,  /* CodePage: 8-bit Unicode transform. fmt. */
                   0,            /* dwFlags: must be NULL for CP_UTF8_win   */
                   string_,      /* lpWideCharStr                           */
                   -1,           /* CCHWideChar - len.-1 = long as required */
                   NULL,         /* lpMultiByteStr                          */
                   0,            /* cbMultiByte:   0 returns # bytes needed */
                   NULL,         /* lpDefaultChar:     NULL for CP_UTF8_win */
                   NULL);        /* lpUsedDefaultChar: NULL for CP_UTF8_win */

    if (dest_len < 1) {
        OS_WARN(_T("WideCharToMultiByte()"), UID(EAC02D));
        RETURN(NULL);
    }

    /* allocate a new character buffer (+ 1 is for \0) */
    ret = CAST(char*, MALLOC(sizeof(char) * CAST(size_t, dest_len + 1)));

    if (ret == NULL) {
        WARN(_T("malloc failed"), UID(E478B5));
        RETURN(NULL);
    }

    CLEAR_N(ret, CAST(size_t, dest_len + 1));

    {
        /* write converted wide characters to character buffer: */
        const int  result = WideCharToMultiByte_win(
                                CP_UTF8_win,   /* CodePage          */
                                0,             /* dwFlags           */
                                string_,       /* lpWideCharStr     */
                                -1,            /* CCHWideChar       */
                                ret,           /* lpMultiByteStr    */
                                dest_len,      /* cbMultiByte       */
                                NULL,          /* lpDefaultChar     */
                                NULL);         /* lpUsedDefaultChar */

        if (!result) {
            OS_WARN(_T("WideCharToMultiByte()"), UID(EF9F52));
            freeA(&ret);
            RETURN(NULL);
        }
    }
#endif                                                      /* PLATFORM_WIN32 */

    RETURN(ret);
} /* _utf8_from_wide */
#endif                                                 /* UNICODE || _UNICODE */


/* -------------------------------------------------------------------------- */
#if PDF_EXTRA_FEATURES > 0


static _color_t  _color_from_text( chars_t  color_name_or_value_ ) {       /*F*/
    GO                                                            (UID(FBD006));
    _color_t  ret            = { 0, 0, 0 };
    int       i              = 0;
    char      color_name[25] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
                               };

    /* if name starts with '#' treat it as an HTML color */
    if (color_name_or_value_[0] == '#') {
        /* HTML colors are specified as #RRGGBB */
        uint8_t  hex[6] = { 0, 0, 0, 0, 0, 0 };

        for (i = 0; i < 6; i++) {
            char  digit = CAST(char, color_name_or_value_[i + 1]);

            if (IS_HEX_DIGIT(digit)) {
                hex[i] = HEX_DIGIT_VAL(digit);

            } else if (digit == '\0') {
                break;

            } else {
                RETURN(ret);    /* return black - conversion failed */
            }
        }
        ret.red   = hex[0] * 16 + hex[1];
        ret.green = hex[2] * 16 + hex[3];
        ret.blue  = hex[4] * 16 + hex[5];
        RETURN(ret);
    }

    /* get color name in lower case, possibly converting from Unicode */
    CLEAR(color_name);
    for (i = 0; i < 25 && color_name_or_value_[i] != '\0'; i++) {
        color_name[i] = CAST(char, color_name_or_value_[i]);
    }
    color_name[24] = '\0';

    _set_lowercase_ascii(color_name);

    for (i = 0; i < 141; i++) {
        const _named_color_t*  color = &_COLOR_NAMES[i];
        if (STRCMP(color_name, color->name) == 0) {
            ret.red   = color->red;
            ret.green = color->green;
            ret.blue  = color->blue;
            RETURN(ret);
        }
    }
    RETURN(ret);
} /* _color_from_text */


static pixel_t  _points_per_unit( chars_t  unit_name_in_lowercase_ ) {     /*F*/
    GO                                                            (UID(F6AD70));
    pixel_t  ret = 0;

    if (STRCMP_T(unit_name_in_lowercase_, _T("mm")) == 0) {
        ret = 2.83464566929134;

        /* 1 inch / 25.4 mm per inch * 72 points per inch */
    } else if (STRCMP_T(unit_name_in_lowercase_, _T("cm")) == 0) {
        ret = 28.3464566929134;

        /* 1 inch / 2.54 cm per inch * 72 points per inch */
    } else if (STRCMP_T(unit_name_in_lowercase_, _T("\""))   == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("in"))     == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("inch"))   == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("inches")) == 0) {
        ret = 72.0;    /* points per inch */

    } else if (STRCMP_T(unit_name_in_lowercase_, _T("tw"))    == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("twip"))  == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("twips")) == 0) {
        ret = 0.05;    /* 1 point / 20 twips per point */

    } else if (STRCMP_T(unit_name_in_lowercase_, _T("pt"))     == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("point"))  == 0 ||
               STRCMP_T(unit_name_in_lowercase_, _T("points")) == 0) {
        ret = 1.0;    /* point */
    }
    RETURN(ret);
} /* _points_per_unit */

#endif                                              /* PDF_EXTRA_FEATURES > 0 */

#if defined __GNUC__
#pragma GCC diagnostic pop
#endif


/* -------------------------------------------------------------------------- */
/* Constructor:                                                               */


PUBLIC new_pdf_t  PdfInit( chars_t  page_size_ ) {                         /*C*/
    GO                                                            (UID(FB76CD));
    /* create a new pdf object */
    _pdf_t*    ob  = _object_alloc();
    new_pdf_t  ret = _object_wrap(ob);

    char  page_size[10];
    int   i = 0;

    ob->compress_streams   = true;
    ob->horizontal_scaling = 100;
    ob->page_no            = NONE;

    /* get page size in lower case, possibly converting from Unicode */
    CLEAR(page_size);
    for (i = 0; i < 10 && page_size_[i] != '\0'; i++) {
        page_size[i] = CAST(char, page_size_[i]);
    }

    page_size[9] = '\0';
    _set_lowercase_ascii(page_size);

    /* get and store dimensions of specified page size (in points) */
    for (i = 0; i < 10; i++) {
        if (STRCMP(page_size, _STANDARD_PAGE_SIZES[i].name) == 0) {
            ob->page_size = _STANDARD_PAGE_SIZES[i];
            break;
        }
    }

    if (ob->page_size.width_pt  <= 0.01 || ob->page_size.height_pt <= 0.01) {
        WARN(_T("Invalid page size."), UID(E1A6C0));
        CLEAR(ob->page_size);
    }

#if defined PDF_EXTRA_FEATURES
    /* store page dimensions */
    ob->page_width_pt  = getPageWidthPtPdf(ret);
    ob->page_height_pt = getPageHeightPtPdf(ret);

    /* set default units, otherwise points_per_unit and all x and y will be 0 */
    setUnitsPdf(ret, _T("point"));
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    RETURN(ret);
} /* PdfInit */


/* -------------------------------------------------------------------------- */
/* Destructor:                                                                */


PUBLIC void  freePdf( pdf_t*  object_ ) {                                  /*D*/
    GO                                                            (UID(FDF033));
    _pdf_t* const  me = _object(object_, UID(E2C1E2));

    /* release all resources and reset all variables: */

    if (me->object_offsets.data != NULL) {
        FREE(me->object_offsets.data);
    }

    CLEAR(me->object_offsets);

    while (me->pages.count > 0) {
        _page_t*  page = _array_get_item(_page_t, me->pages,
                                         me->pages.count - 1);
        if (page->font_ids.data != NULL) {
            FREE(page->font_ids.data);
        }

        if (page->page_content.chars != NULL) {
            FREE(page->page_content.chars);
        }

        me->pages.count--;
    }

    if (me->pages.data != NULL) {
        FREE(me->pages.data);
    }

    CLEAR(me->pages);

    if (me->fonts.data != NULL) {
        FREE(me->fonts.data);
    }

    freeA(&me->content.chars);

    CLEAR(me->content);

    freeT(&me->doc_author);
    freeT(&me->doc_creator);
    freeT(&me->doc_keywords);
    freeT(&me->doc_subject);
    freeT(&me->doc_title);

#if PDF_EXTRA_FEATURES > 0
    freeT(&me->unit_name);

    if (me->column_widths != NULL) {
        FREE(me->column_widths);
    }
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    _object_free(object_);
    RETURN(NIL);
} /* freePdf */


/* -------------------------------------------------------------------------- */
/* Properties:                                                                */


PUBLIC bool  getCompressionPdf( const pdf_t  object_ ) {                   /*P*/
    GO                                                            (UID(F729FA));
    const _pdf_t* const  me  = _object(&object_, UID(EA609B));
    const bool           ret = me->compress_streams;
    RETURN(ret);
} /* getCompressionPdf */


PUBLIC void  setCompressionPdf(                                            /*P*/
    pdf_t       object_,                                                   /*-*/
    const bool  value_ ) {                                                 /*-*/
    GO                                                            (UID(FB4E6F));
    _pdf_t* const  me = _object(&object_, UID(E27E34));
    me->compress_streams = value_;
    RETURN(NIL);
} /* setCompressionPdf */


PUBLIC chars_t  getDocAuthorPdf( const pdf_t  object_ ) {                  /*P*/
    GO                                                            (UID(F07516));
    const _pdf_t* const  me  = _object(&object_, UID(E05934));
    chars_t              ret = me->doc_author ? me->doc_author : _T("");
    RETURN(ret);
} /* getDocAuthorPdf */


PUBLIC void  setDocAuthorPdf(                                              /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(F9A44A));
    _pdf_t* const  me = _object(&object_, UID(E23BB3));
    _store_info_field(value_, &me->doc_author);
    RETURN(NIL);
} /* setDocAuthorPdf */


PUBLIC chars_t  getDocCreatorPdf( const pdf_t  object_ ) {                 /*P*/
    GO                                                            (UID(F6C854));
    const _pdf_t* const  me  = _object(&object_, UID(ED803B));
    chars_t              ret = me->doc_creator ? me->doc_creator : _T("");
    RETURN(ret);
} /* getDocCreatorPdf */


PUBLIC void  setDocCreatorPdf(                                             /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(F2D447));
    _pdf_t* const  me = _object(&object_, UID(E8F051));
    _store_info_field(value_, &me->doc_creator);
    RETURN(NIL);
} /* setDocCreatorPdf */


PUBLIC chars_t  getDocKeywordsPdf( const pdf_t  object_ ) {                /*P*/
    GO                                                            (UID(F8A471));
    const _pdf_t* const  me  = _object(&object_, UID(E876C0));
    chars_t              ret = me->doc_keywords ? me->doc_keywords : _T("");
    RETURN(ret);
} /* getDocKeywordsPdf */


PUBLIC void  setDocKeywordsPdf(                                            /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(F61C45));
    _pdf_t* const  me = _object(&object_, UID(EEEFD6));
    _store_info_field(value_, &me->doc_keywords);
    RETURN(NIL);
} /* setDocKeywordsPdf */


PUBLIC chars_t  getDocSubjectPdf( const pdf_t  object_ ) {                 /*P*/
    GO                                                            (UID(F39811));
    const _pdf_t* const  me  = _object(&object_, UID(E5D9A8));
    chars_t              ret = me->doc_subject ? me->doc_subject : _T("");
    RETURN(ret);
} /* getDocSubjectPdf */


PUBLIC void  setDocSubjectPdf(                                             /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(F31439));
    _pdf_t* const  me = _object(&object_, UID(EFAFC4));
    _store_info_field(value_, &me->doc_subject);
    RETURN(NIL);
} /* setDocSubjectPdf */


PUBLIC chars_t  getDocTitlePdf( const pdf_t  object_ ) {                   /*P*/
    GO                                                            (UID(FF0AD6));
    const _pdf_t* const  me = _object(&object_, UID(EC5D00));
    chars_t  ret = me->doc_title ? me->doc_title : _T("");
    RETURN(ret);
} /* getDocTitlePdf */


PUBLIC void  setDocTitlePdf(                                               /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(F03CD5));
    _pdf_t* const  me = _object(&object_, UID(EB2933));
    _store_info_field(value_, &me->doc_title);
    RETURN(NIL);
} /* setDocTitlePdf */


PUBLIC chars_t  getFontNamePdf( const pdf_t  object_ ) {                   /*P*/
    GO                                                            (UID(F8623E));
    const _pdf_t* const  me  = _object(&object_, UID(EE1598));
    chars_t              ret = me->font.font_name;
    RETURN(ret);
} /* getFontNamePdf */


PUBLIC void  setFontNamePdf(                                               /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(F25456));
    _pdf_t* const  me = _object(&object_, UID(E85FBF));
    _set_char_array(me->font.font_name, value_);
    RETURN(NIL);
} /* setFontNamePdf */


PUBLIC pixel_t  getFontSizePtPdf( const pdf_t  object_ ) {                 /*P*/
    GO                                                            (UID(F40B7B));
    const _pdf_t* const  me  = _object(&object_, UID(E210B9));
    const pixel_t        ret = me->font_size_pt;
    RETURN(ret);
} /* getFontSizePtPdf */


PUBLIC void  setFontSizePtPdf(                                             /*P*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  font_size_in_points_ ) {                                /*-*/
    GO                                                            (UID(F0762A));
    _pdf_t* const  me = _object(&object_, UID(ED1741));
    me->font_size_pt = font_size_in_points_;
    RETURN(NIL);
} /* setFontSizePtPdf */


PUBLIC uint16_t  getHorizontalScalingPdf( const pdf_t  object_ ) {         /*P*/
    GO                                                            (UID(FC583D));
    const _pdf_t* const  me  = _object(&object_, UID(E7FDFA));
    const uint16_t       ret = me->horizontal_scaling;
    RETURN(ret);
} /* getHorizontalScalingPdf */


PUBLIC void  setHorizontalScalingPdf(                                      /*P*/
    pdf_t           object_,                                               /*-*/
    const uint16_t  value_ ) {                                             /*-*/
    GO                                                            (UID(F05ACF));
    _pdf_t* const  me = _object(&object_, UID(E33542));
    me->horizontal_scaling = value_;
    RETURN(NIL);
} /* setHorizontalScalingPdf */


PUBLIC pixel_t  getLineWidthPtPdf( const pdf_t  object_ ) {                /*P*/
    GO                                                            (UID(F422F3));
    const _pdf_t* const  me  = _object(&object_, UID(E781FB));
    const pixel_t        ret = me->line_width;
    RETURN(ret);
} /* getLineWidthPtPdf */


PUBLIC void  setLineWidthPdfPt(                                            /*P*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  value_ ) {                                              /*-*/
    GO                                                            (UID(F33866));
    _pdf_t* const  me = _object(&object_, UID(EC138F));
    me->line_width = value_;
    RETURN(NIL);
} /* setLineWidthPdfPt */


PUBLIC pixel_t  getXPdf( const pdf_t  object_ ) {                          /*P*/
    GO                                                            (UID(F2C65C));
    _pdf_t* const  me = _object(&object_, UID(EAFE48));
    _WARN_AND_RETURN_IF_NO_PAGE(UID(E75E47), 0);
    {
        pixel_t  ret = me->page->x;
#if PDF_EXTRA_FEATURES > 0
        ret /= me->points_per_unit;
#endif
        RETURN(ret);
    }
} /* getXPdf */


PUBLIC void  setXPdf(                                                      /*P*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  x_ ) {                                                  /*-*/
    GO                                                            (UID(F06638));
    _pdf_t* const  me = _object(&object_, UID(ED2F44));
    pixel_t        x  = x_;

    _WARN_AND_RETURN_IF_NO_PAGE(UID(E51709), NULL_STATEMENT);

#if PDF_EXTRA_FEATURES > 0
    x *= me->points_per_unit;
#endif

    me->page->x = x;
    RETURN(NIL);
} /* setXPdf */


PUBLIC pixel_t  getYPdf( const pdf_t  object_ ) {                          /*P*/
    GO                                                            (UID(FD9E98));
    _pdf_t* const  me = _object(&object_, UID(E150D5));

    _WARN_AND_RETURN_IF_NO_PAGE(UID(E35B1F), 0);
    {
        pixel_t  ret = me->page->y;

#if PDF_EXTRA_FEATURES > 0
#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
        ret = me->page_height_pt - ret;
#endif
        ret /= me->points_per_unit;
#endif                                              /* PDF_EXTRA_FEATURES > 0 */
        RETURN(ret);
    }
} /* getYPdf */


PUBLIC void  setYPdf(                                                      /*P*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  y_ ) {                                                  /*-*/
    GO                                                            (UID(F21FBC));
    _pdf_t* const  me = _object(&object_, UID(EE5878));
    pixel_t        y  = y_;

    _WARN_AND_RETURN_IF_NO_PAGE(UID(E9FA0F), NULL_STATEMENT);

#if PDF_EXTRA_FEATURES > 0
    y *= me->points_per_unit;
#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    y = (me->page_height_pt * me->points_per_unit) - y;
#endif
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    me->page->y = y;
    RETURN(NIL);
} /* setYPdf */


PUBLIC void  setXyPdf(                                                     /*P*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  x_,                                                     /*-*/
    const pixel_t  y_ ) {                                                  /*-*/
    GO                                                            (UID(FA7AA3));
    _pdf_t* const  me = _object(&object_, UID(E6A089));
    pixel_t        x  = x_;
    pixel_t        y  = y_;

    _WARN_AND_RETURN_IF_NO_PAGE(UID(EC4AD7), ;);

#if PDF_EXTRA_FEATURES > 0
    x *= me->points_per_unit;
    y *= me->points_per_unit;
#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    y = me->page_height_pt - y;
#endif
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    me->page->x = x;
    me->page->y = y;

    RETURN(NIL);
} /* setXyPdf */


/* -------------------------------------------------------------------------- */
/* Properties: Read-Only                                                      */


PUBLIC int  getCurrentPagePdf( const pdf_t  object_ ) {                    /*P*/
    GO                                                            (UID(F04E74));
    const _pdf_t* const  me  = _object(&object_, UID(E9A707));
    const int            ret = me->page_no;
    RETURN(ret);
} /* getCurrentPagePdf */


PUBLIC pixel_t  getPageHeightPtPdf( const pdf_t  object_ ) {               /*P*/
    GO                                                            (UID(F50AF4));
    _pdf_t* const  me  = _object(&object_, UID(ED5181));
    pixel_t        ret = 0;

    if (me->page_no == NONE || me->page_no > (me->pages.count - 1) ||
        me->page == NULL) {
        ret = me->page_size.height_pt;
    } else {
        ret = me->page->page_size.height_pt;
    }
    RETURN(ret);
} /* getPageHeightPtPdf */


PUBLIC pixel_t  getPageWidthPtPdf( const pdf_t  object_ ) {                /*P*/
    GO                                                            (UID(F3F145));
    _pdf_t* const  me  = _object(&object_, UID(E606DE));
    pixel_t        ret = 0;

    if (me->page_no == NONE || me->page_no > (me->pages.count - 1) ||
        me->page == NULL) {
        ret = me->page_size.width_pt;
    } else {
        ret = me->page->page_size.width_pt;
    }
    RETURN(ret);
} /* getPageWidthPtPdf */


/* -------------------------------------------------------------------------- */
/* Additional Properties:                                                     */


#if PDF_EXTRA_FEATURES > 0
PUBLIC chars_t  getUnitsPdf( const pdf_t  object_ ) {                      /*P*/
    GO                                                            (UID(FB0B70));
    _pdf_t* const  me  = _object(&object_, UID(E1D473));
    chars_t        ret = me->unit_name;
    RETURN(ret);
} /* getUnitsPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  setUnitsPdf(                                                  /*P*/
    pdf_t    object_,                                                      /*-*/
    chars_t  value_ ) {                                                    /*-*/
    GO                                                            (UID(FAD81F));
    _pdf_t* const  me  = _object(&object_, UID(EA1E71));
    const size_t   len = STRLEN_T(value_);

    /* copy value_ to lowercase character string unit_name */

    freeT(&me->unit_name);
    me->unit_name = CAST(char_t*, MALLOC((len + 1) * sizeof(char_t)));
    STRCPY_S_T(me->unit_name, len + 1, value_);
    {
        /* (later, create a function from this) */
        char_t*  ch = me->unit_name;
        while (ch && *ch) {
            *ch = CAST(char_t, TOLOWER_T(*ch));
            ch++;
        }
    }
    me->points_per_unit = _points_per_unit(me->unit_name);
    RETURN(NIL);
} /* setUnitsPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


/* -------------------------------------------------------------------------- */
/* Methods:                                                                   */


PUBLIC void  addPagePdf( pdf_t  object_ ) {                                /*M*/
    GO                                                            (UID(F20091));
    _pdf_t* const   me   = _object(&object_, UID(E1CD81));
    _page_t* const  page = _array_add_item(_page_t, me->pages);
    CLEAR(*page);

    _set_curr_page(me, me->pages.count - 1);
    me->page_no = me->pages.count - 1;

    page->page_size          = me->page_size;
    page->horizontal_scaling = 100;
    page->page_content.cap   = 0;
    page->page_content.len   = 0;
    page->page_content.chars = NULL;

    /* these variables must default to -1 */
    page->x = -1;
    page->y = -1;

    page->color_stroke.red   = 1;
    page->color_stroke.green = 1;
    page->color_stroke.blue  = 1;

    page->color_non_stroke.red   = 1;
    page->color_non_stroke.green = 1;
    page->color_non_stroke.blue  = 1;

#if PDF_EXTRA_FEATURES > 0
#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    setXyPdf(object_, 0, 0);
#endif
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    RETURN(NIL);
} /* addPagePdf */


PUBLIC void  drawBoxPdf(                                                   /*M*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  x_,                                                     /*-*/
    const pixel_t  y_,                                                     /*-*/
    const pixel_t  width_,                                                 /*-*/
    const pixel_t  height_ ) {                                             /*-*/
    GO                                                            (UID(F913E9));
    _pdf_t* const  me = _object(&object_, UID(E2E93D));

    double  x      = CAST(double, x_);
    double  y      = CAST(double, y_);
    double  width  = CAST(double, width_);
    double  height = CAST(double, height_);

    _WARN_AND_RETURN_IF_NO_PAGE(UID(E63659), NULL_STATEMENT);

#if PDF_EXTRA_FEATURES > 0
    x      *= me->points_per_unit;
    y      *= me->points_per_unit;
    width  *= me->points_per_unit;
    height *= me->points_per_unit;

#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    y = me->page_height_pt - y - height;
#endif

#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    _set_line_width(me);
    _set_stroke_color(me);

    /* re = construct a rectangular path, S = stroke path */
    _printf(me, "%.3f %.3f %.3f %.3f re S" "\n", x, y, width, height);
    RETURN(NIL);
} /* drawBoxPdf */


PUBLIC void  fillBoxPdf(                                                   /*M*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  x_,                                                     /*-*/
    const pixel_t  y_,                                                     /*-*/
    const pixel_t  width_,                                                 /*-*/
    const pixel_t  height_ ) {                                             /*-*/
    GO                                                            (UID(FFFE11));
    _pdf_t* const  me = _object(&object_, UID(EFF6E1));

    double  x      = CAST(double, x_);
    double  y      = CAST(double, y_);
    double  width  = CAST(double, width_);
    double  height = CAST(double, height_);

    _WARN_AND_RETURN_IF_NO_PAGE(UID(E0D813), NULL_STATEMENT);

#if PDF_EXTRA_FEATURES > 0
    x      *= me->points_per_unit;
    y      *= me->points_per_unit;
    width  *= me->points_per_unit;
    height *= me->points_per_unit;

#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    y = me->page_height_pt - y - height;
#endif
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    _set_line_width(me);
    _set_non_stroke_color(me);
    _printf(me, "%.3f %.3f %.3f %.3f re f" "\n", x, y, width, height);
    /*                            re = construct a rectangular path, f = fill */
    RETURN(NIL);
} /* fillBoxPdf */


PUBLIC void  setColorRgbPdf(                                               /*M*/
    pdf_t      object_,                                                    /*-*/
    const int  red_,                                                       /*-*/
    const int  green_,                                                     /*-*/
    const int  blue_ ) {                                                   /*-*/
    GO                                                            (UID(F38CEB));
    _pdf_t* const  me = _object(&object_, UID(E605D6));

    _color_t  color = { 0, 0, 0 };
    color.red        = CAST(uint8_t, red_);
    color.green      = CAST(uint8_t, green_);
    color.blue       = CAST(uint8_t, blue_);
    me->color        = color;
    RETURN(NIL);
} /* setColorRgbPdf */


PUBLIC void  drawLinePdf(                                                  /*M*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  x1_,                                                    /*-*/
    const pixel_t  y1_,                                                    /*-*/
    const pixel_t  x2_,                                                    /*-*/
    const pixel_t  y2_ ) {                                                 /*-*/
    GO                                                            (UID(FCF33F));
    _pdf_t* const  me = _object(&object_, UID(ECAB14));
    double  x1 = CAST(double, x1_);
    double  y1 = CAST(double, y1_);
    double  x2 = CAST(double, x2_);
    double  y2 = CAST(double, y2_);

    _WARN_AND_RETURN_IF_NO_PAGE(UID(EE0753), NULL_STATEMENT);

#if PDF_EXTRA_FEATURES > 0

    x1 *= me->points_per_unit;
    y1 *= me->points_per_unit;
    x2 *= me->points_per_unit;
    y2 *= me->points_per_unit;

#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    y1 = me->page_height_pt - y1;
    y2 = me->page_height_pt - y2;
#endif                                               /* _START_Y_FROM_TOP > 0 */

#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    _set_line_width(me);
    _set_stroke_color(me);

    /* send command to draw the line */
    _printf(me, "%.3f %.3f m %.3f %.3f l S" "\n", x1, y1, x2, y2);
    RETURN(NIL);
} /* drawLinePdf */


#if defined __GNUC__ || defined __clang__
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#endif


/* TODO: get rid of object_ once unpacked functions created */
PUBLIC void  _draw_text(                                                   /*M*/
    pdf_t    object_,                                                      /*-*/
    _pdf_t*  me_,                                                          /*-*/
    chars_t  text_ ) {                                                     /*-*/
    GO                                                            (UID(F50F04));
    const size_t  text_len = (!text_ ? 0 : STRLEN_T(text_));

    if (text_len == 0) {
        RETURN(NIL);
    }

    _set_font(me_);
    _set_horizontal_scaling(me_);
    _set_non_stroke_color(me_);

    if (me_->page->x < 0 || me_->page->y < 0) {
        setXyPdf(object_, 0, 0);
    }
    /* TODO: create unpacked _set_xy() */

    {
        bool          need_to_free = false;
        new_bchars_t  packed_text  = NULL;

#if defined UNICODE || defined _UNICODE
        char*   converted_text = CAST(char*, MALLOC(text_len + 1));
        size_t  i              = 0;

        for (i = 0; i < text_len && text_[i] != '\0'; i++) {
            converted_text[i] = CAST(char, text_[i]);
        }

        converted_text[i] = '\0';
        packed_text = _pack_text(converted_text, &need_to_free);
#else                                                  /* UNICODE || _UNICODE */
        packed_text = _pack_text(text_, &need_to_free);
#endif                                               /* !UNICODE && !_UNICODE */
        _printf(me_,
                "BT %d %d Td (%s) Tj ET" "\n",
                CAST(int,   me_->page->x),
                CAST(int,   me_->page->y),
                CAST(char*, packed_text));

#if defined UNICODE || defined _UNICODE
        freeA(&converted_text);
#endif

        if (need_to_free) {
            freeA(&packed_text);
        }

        {
            const pixel_t  text_width = getTextWidthPdf(object_, text_);
            me_->page->x += text_width;
        }
        /* TODO: create unpacked _get_width_of_text() */
    }
    RETURN(NIL);
} /* _draw_text */  /* TODO: move into group of private functions */


PUBLIC void  drawTextPdf(                                                  /*M*/
    pdf_t    object_,                                                      /*-*/
    chars_t  text_ ) {                                                     /*-*/
    GO                                                            (UID(F15B6B));
    _pdf_t* const  me = _object(&object_, UID(E62D66));

    _WARN_AND_RETURN_IF_NO_PAGE(UID(E52DE7), NULL_STATEMENT);

#if PDF_EXTRA_FEATURES > 0
    if (me->col_count > 0) {
        size_t   i = 0;
        pixel_t  x = 0;

        for (i = 0; i < me->column; i++) {
            x += me->column_widths[i];
        }

        setXPdf(object_, x);

        _draw_text(object_, me, text_);

        if (me->column == (me->col_count - 1)) {
            goToNextLinePdf(object_);
        } else {
            me->column++;
        }
    } else {
        _draw_text(object_, me, text_);
    }
#else
    _draw_text(object_, me, text_);
#endif                                              /* PDF_EXTRA_FEATURES > 0 */

    RETURN(NIL);
} /* drawTextPdf */


PUBLIC pixel_t  getTextWidthPdf(                                           /*M*/
    const pdf_t  object_,                                                  /*-*/
    chars_t      text_ ) {                                                 /*-*/
    GO                                                            (UID(F17C64));
    const _pdf_t* const  me  = _object(&object_, UID(EF6D84));
    pixel_t              ret = 0;

    /* warn and return if no current page */
    if (me->page_no == NONE                 ||
        me->page_no > (me->pages.count - 1) ||
        me->page == NULL) {
        WARN(_T("No current page."), UID(E74922));
        RETURN(0);

    } else if (text_ == NULL) {
        RETURN(0);

    } else {
        const int*  char_widths = _WIDTHS_HELVETICA;
        /* TODO: multiple fonts */

        pixel_t  char_width = 0;

        while (*text_) {
            const int  ch = *text_++;
            ASSERT(ch >= 0 && ch <= 255, UID(E1E6CB));
            char_width = char_widths[ch];
            ret += char_width;
        }
    }
    ret = ret * me->font_size_pt / 1000
          * CAST(pixel_t, me->horizontal_scaling)  / 100;
    RETURN(ret);
} /* getTextWidthPdf */


/* -------------------------------------------------------------------------- */
/* Core Methods for Document Output:                                          */


PUBLIC new_bytes_t  BytesFromPdf( const pdf_t  object_ ) {                 /*M*/
    GO                                                            (UID(FF2DDE));
    _pdf_t* const  me = _object(&object_, UID(EF3B1B));
    new_bytes_t  ret = { 0, NULL };
    _compose_pdf(me);
    ret = Bytes_init(CAST(uint8_t*, me->content.chars), me->content.len);
    RETURN(ret);
} /* BytesFromPdf */


PUBLIC void  saveToFilePdf(                                                /*M*/
    const pdf_t  object_,                                                  /*-*/
    chars_t      filename_ ) {                                             /*-*/
    GO                                                            (UID(F5C004));
    _pdf_t* const  me   = _object(&object_, UID(E88AD9));
    FILE*          file = NULL;
    _compose_pdf(me);

#if defined _MSC_VER
#pragma warning (push)
#pragma warning (disable:4996)  /* W:L3 'function': may be unsafe/deprecated  */
#endif

    /* save to local file */
#if defined UNICODE || defined _UNICODE
    file = WFOPEN(filename_, L"wb");
#else                                                  /* UNICODE || _UNICODE */
    file = FOPEN(filename_, "wb");
#endif                                               /* !UNICODE && !_UNICODE */

#if defined _MSC_VER
#pragma warning (pop)
#endif

    if (!file) {
        WARN(_T("Unable to create output file"), UID(E77853));
    }

    fwrite(me->content.chars, sizeof(char), me->content.len, file);
    fclose(file);
    RETURN(NIL);
} /* saveToFilePdf */


/* -------------------------------------------------------------------------- */
/* Additional Methods:                                                        */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  drawTextInBoxPdf(                                             /*M*/
    pdf_t          object_,                                                /*-*/
    chars_t        text_,                                                  /*-*/
    chars_t        text_align_,                                            /*-*/
    const pixel_t  x_,                                                     /*-*/
    const pixel_t  y_,                                                     /*-*/
    const pixel_t  width_,                                                 /*-*/
    const pixel_t  height_ ) {                                             /*-*/
    GO                                                            (UID(F66674));
    _pdf_t* const  me = _object(&object_, UID(E9EFFF));

    const int      page_no    = getCurrentPagePdf(object_);
    const pixel_t  width      = width_  * me->points_per_unit;
    const pixel_t  height     = height_ * me->points_per_unit;
    const pixel_t  x          = x_      * me->points_per_unit;
    pixel_t        y          = y_      * me->points_per_unit;
    pixel_t        text_x     = 0;
    pixel_t        text_y     = 0;
    uint8_t        horizontal = 'c';  /* center */
    uint8_t        vertical   = 'c';  /* center */

    /* ensure there is a current page */
    if (page_no < 0) {
        WARN(_T("No current page."), UID(E7F50A));
        RETURN(NIL);
    }

    {
        /* determine horizontal and vertical text alignment */
        chars_t  rd = text_align_;
        while (rd && *rd) {
            if (*rd == 'l' || *rd == 'L') {
                horizontal = 'l';    /* left   */
            } else if (*rd == 'r' || *rd == 'R') {
                horizontal = 'r';    /* right  */
            } else if (*rd == 't' || *rd == 'T') {
                vertical = 't';      /* top    */
            } else if (*rd == 'b' || *rd == 'B') {
                vertical = 'b';      /* bottom */
            }
            rd++;
        }
    }

    /* calculate x-axis position of text */
    if (horizontal == 'l') { /* left */
        text_x = x;
        text_x += me->font_size_pt / 6;

    } else if (horizontal == 'c') {  /* center */
        const pixel_t  center     = x + (width / 2);
        const pixel_t  text_width = getTextWidthPdf(object_, text_);
        text_x = center - (text_width / 2);

    } else if (horizontal == 'r') { /* right */
        const pixel_t  text_width = getTextWidthPdf(object_, text_);
        text_x = x + width - text_width;
        text_x -= me->font_size_pt / 6;
    }

    /* calculate y-axis position of text */

#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0
    y = me->page_height_pt - y - height;
#endif

    if (vertical == 'b') { /* bottom */
        text_y = y;
        text_y += me->font_size_pt / 3;

    } else if (vertical == 'c') {  /* center */
        const pixel_t  center      = y + (height / 2);
        const pixel_t  text_height = me->font_size_pt;
        text_y = center - (text_height / 2);
        text_y += me->font_size_pt / 6;
    } else if (vertical == 't') { /* top */
        const pixel_t  text_height = me->font_size_pt;
        text_y = y + height - text_height;
    }

    me->page->x = text_x;
    me->page->y = text_y;
    drawTextPdf(object_, text_);

    RETURN(NIL);
} /* drawTextInBoxPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  drawUnitGridPdf( pdf_t  object_ ) {                           /*M*/
    GO                                                            (UID(FB9D95));
    _pdf_t* const  me = _object(&object_, UID(EF8F86));

    /* all values are in points */

    const pixel_t  page_width  =
        getPageWidthPtPdf(object_) / me->points_per_unit;

    const pixel_t  page_height =
        getPageHeightPtPdf(object_) / me->points_per_unit;

    pixel_t  x = 0;
    pixel_t  y = 0;

    /* ensure there is a current page */
    if (getCurrentPagePdf(object_) < 0) {
        WARN(_T("No current page."), UID(E400E5));
        RETURN(NIL);
    }

    setLineWidthPdfPt(object_, 0.1);
    setColorRgbPdf(object_, 200, 200, 200);

    /* draw vertical lines */
    for (x = 0; x < page_width; x += 1) {
        drawLinePdf(object_, x, 0, x, page_height);
    }

    /* draw horizontal lines */
#if defined _START_Y_FROM_TOP && _START_Y_FROM_TOP > 0

    for (y = page_height; y > 0; y -= 1)
#else                                                /* _START_Y_FROM_TOP > 0 */
    for (y = 0; y < page_height; y += 1)
#endif                                              /* !_START_Y_FROM_TOP > 0 */
    {
        drawLinePdf(object_, 0, y, page_width, y);
    }
    RETURN(NIL);
} /* drawUnitGridPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  goToNextLinePdf( pdf_t  object_ ) {                           /*M*/
    GO                                                            (UID(F6FF11));
    _pdf_t* const  me = _object(&object_, UID(E6CE34));

    pixel_t  x           = getXPdf(object_);
    pixel_t  y           = getYPdf(object_);
    pixel_t  line_height = getFontSizePtPdf(object_);
    pixel_t  page_height = me->page_height_pt;

    line_height *= me->points_per_unit;
    page_height *= me->points_per_unit;
    y += line_height;

    if (y > page_height) {
        addPagePdf(object_);
        y = 0;
    }

    me->column = 0;

    if (me->col_count == 0) {
        x = 0;
    } else {
        x = me->column_widths[0];
    }

    setXyPdf(object_, x, y);
    RETURN(NIL);
} /* goToNextLinePdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  setColorPdf(                                                  /*M*/
    pdf_t    object_,                                                      /*-*/
    chars_t  color_name_or_value_ ) {                                      /*-*/
    GO                                                            (UID(F5B855));
    const _color_t  color = _color_from_text(color_name_or_value_);
    setColorRgbPdf(object_, color.red, color.green, color.blue);
    RETURN(NIL);
} /* setColorPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  setColumnWidthsPdf(                                           /*M*/
    pdf_t           object_,                                               /*-*/
    const uint32_t  number_of_columns_,                                    /*-*/
    ... ) {                                                                /*-*/
    GO                                                            (UID(F984D5));
    _pdf_t* const  me = _object(&object_, UID(E25EC7));
    size_t         i  = 0;
    va_list        args;

    /* make sure number_of_columns_ is within reasonable limits */
    if (number_of_columns_ < 1) {
        ERR(_T("number_of_columns_ < 1"), UID(EB7539));
        RETURN(NIL);
    }

    if (number_of_columns_ > 1000) {
        ERR(_T("number_of_columns_ > 1000"), UID(EE9870));
        RETURN(NIL);
    }

    me->col_count = number_of_columns_;
    me->column_widths = CAST(pixel_t*,
                             MALLOC(number_of_columns_ * sizeof(pixel_t)));

    va_start(args, number_of_columns_);
    for (i = 0; i < number_of_columns_; i++) {
        const pixel_t  width = va_arg(args, pixel_t);
        me->column_widths[i] = width;
    }
    va_end(args);
    RETURN(NIL);
} /* setColumnWidthsPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


#if PDF_EXTRA_FEATURES > 0
PUBLIC void  setLineWidthPdf(                                              /*M*/
    pdf_t          object_,                                                /*-*/
    const pixel_t  line_width_in_points_ ) {                               /*-*/
    GO                                                            (UID(F7222B));
    _pdf_t* const  me = _object(&object_, UID(E9A6A5));
    setLineWidthPdfPt(object_, line_width_in_points_ * me->points_per_unit);
    RETURN(NIL);
} /* setLineWidthPdf */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


/* -------------------------------------------------------------------------- */
/* Additional Functions:                                                      */


#if PDF_EXTRA_FEATURES > 0
PUBLIC pixel_t  convert_to_pdf_points( chars_t  number_and_unit_ ) {       /*F*/
    GO                                                            (UID(FA73C6));
#define MAX_VAL_LEN   40
#define MAX_UNIT_LEN  7

    pixel_t  ret = 0;

    /* read value and unit into separate strings */

    char_t  val[MAX_VAL_LEN];
    char_t  unit_name[MAX_UNIT_LEN];
    CLEAR(val);
    CLEAR(unit_name);

    if (number_and_unit_ != NULL) {
        chars_t  rd       = number_and_unit_;
        char_t*  wr       = val;
        char_t*  unit     = unit_name;
        size_t   val_len  = 0;
        size_t   unit_len = 0;

        while (*rd != '\0') {
            if (unit_len == 0 &&
                (IS_DIGIT(*rd) || *rd == '.' || *rd == '-')) {

                if (val_len < MAX_VAL_LEN) {
                    *wr++ = *rd;
                    val_len++;
                }
            } else if ((IS_ALPHA(*rd) || *rd == '"') && unit_len < MAX_UNIT_LEN) {
                *unit++ = CAST(char_t, TOLOWER_T(*rd));
                unit_len++;
            }
            rd++;
        }
        *wr   = '\0';
        *unit = '\0';
    }

    ret = ATOF_T(val);

    /* determine number of points per unit */
    if (unit_name[0] != '\0') {
        const pixel_t  points_per_unit = _points_per_unit(unit_name);

        if (CAST(int, points_per_unit * 1000000) == 0) {
            WARN(_T("Unknown unit name."), UID(ECA7E5));
        }

        ret *= points_per_unit;
    }
    RETURN(ret);
} /* convert_to_pdf_points */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


/* TODO: Create a unit test file and move this code to the unit test. */
#if PDF_EXTRA_FEATURES > 0
PUBLIC void  test_convert_to_pdf_points( void ) {                          /*F*/
    GO                                                            (UID(F4FD43));
#if defined _MSC_VER
#pragma warning (push)
#pragma warning (disable:4820)  /* W:L4 'N' bytes padding added after 'NAME'  */
#endif

    struct _test_t {
        chars_t  number_and_unit_;                                 /* _test_t */
        pixel_t  expect_result;                                    /* _test_t */
    }

#if defined _MSC_VER
#pragma warning (pop)
#endif

    test[] = {

        { _T("1\""), 72.0 },

        /* number_and_unit_ expect_result */

        { NULL, 0 },   /*null-test*/

        /* test various blank strings */
        { _T(""),        0 },
        { _T(" "),       0 },
        { _T("  "),      0 },
        { _T("   "),     0 },
        { _T("    "),    0 },
        { _T("     "),   0 },
        { _T("      "),  0 },
        { _T("       "), 0 },
        { _T("\n"),      0 },
        { _T("\n\n"),    0 },
        { _T("\r"),      0 },
        { _T("\t"),      0 },
        { _T("\b"),      0 },

        /* single unit */
        { _T("1mm"),     2.83464566929134 },
        { _T("1cm"),     28.3464566929134 },
        { _T("1in"),     72.0 },
        { _T("1\""),     72.0 },
        { _T("1inch"),   72.0 },
        { _T("1inches"), 72.0 },
        { _T("1tw"),     0.05 },
        { _T("1twip"),   0.05 },
        { _T("1twips"),  0.05 },
        { _T("1pt"),     1 },
        { _T("1point"),  1 },
        { _T("1points"), 1 },

        /* single unit */
        { _T("1 mm"),     2.83464566929134 },
        { _T("1 cm"),     28.3464566929134 },
        { _T("1 in"),     72.0 },
        { _T("1 \""),     72.0 },
        { _T("1 inch"),   72.0 },
        { _T("1 inches"), 72.0 },
        { _T("1 tw"),     0.05 },
        { _T("1 twip"),   0.05 },
        { _T("1 twips"),  0.05 },
        { _T("1 pt"),     1 },
        { _T("1 point"),  1 },
        { _T("1 points"), 1 },

        /* single unit */
        { _T("1.0 mm"),     2.83464566929134 },
        { _T("1.0 cm"),     28.3464566929134 },
        { _T("1.0 in"),     72.0 },
        { _T("1.0 \""),     72.0 },
        { _T("1.0 inch"),   72.0 },
        { _T("1.0 inches"), 72.0 },
        { _T("1.0 tw"),     0.05 },
        { _T("1.0 twip"),   0.05 },
        { _T("1.0 twips"),  0.05 },
        { _T("1.0 pt"),     1 },
        { _T("1.0 point"),  1 },
        { _T("1.0 points"), 1 },

        /* single unit (upper-case)  */
        { _T("1MM"),     2.83464566929134 },
        { _T("1CM"),     28.3464566929134 },
        { _T("1IN"),     72.0 },
        { _T("1INCH"),   72.0 },
        { _T("1INCHES"), 72.0 },
        { _T("1TW"),     0.05 },
        { _T("1TWIP"),   0.05 },
        { _T("1TWIPS"),  0.05 },
        { _T("1PT"),     1 },
        { _T("1POINT"),  1 },
        { _T("1POINTS"), 1 },

        /* single unit (upper-case)  */
        { _T("1 MM"),     2.83464566929134 },
        { _T("1 CM"),     28.3464566929134 },
        { _T("1 IN"),     72.0 },
        { _T("1 INCH"),   72.0 },
        { _T("1 INCHES"), 72.0 },
        { _T("1 TW"),     0.05 },
        { _T("1 TWIP"),   0.05 },
        { _T("1 TWIPS"),  0.05 },
        { _T("1 PT"),     1 },
        { _T("1 POINT"),  1 },
        { _T("1 POINTS"), 1 },

        /* single unit (upper-case) */
        { _T("1.0 MM"),     2.83464566929134 },
        { _T("1.0 CM"),     28.3464566929134 },
        { _T("1.0 IN"),     72.0 },
        { _T("1.0 INCH"),   72.0 },
        { _T("1.0 INCHES"), 72.0 },
        { _T("1.0 TW"),     0.05 },
        { _T("1.0 TWIP"),   0.05 },
        { _T("1.0 TWIPS"),  0.05 },
        { _T("1.0 PT"),     1 },
        { _T("1.0 POINT"),  1 },
        { _T("1.0 POINTS"), 1 },

        /* single unit (various permutations) */
        { _T("1       c m"), 28.3464566929134 },
        { _T("1 Cm"),        28.3464566929134 },
        { _T(" 1 C m"),      28.3464566929134 },
        { _T(" 1C m"),       28.3464566929134 },
        { _T("1CM"),         28.3464566929134 },
        { _T("1 CM"),        28.3464566929134 },
        { _T(" 1 CM"),       28.3464566929134 },
        { _T("01CM"),        28.3464566929134 },
        { _T("01 CM"),       28.3464566929134 },
        { _T("01 CM"),       28.3464566929134 },
        { _T("1cM"),         28.3464566929134 },
        { _T("1 M"),         28.3464566929134 },
        { _T(" 1 M"),        28.3464566929134 },
        { _T("01cM"),        28.3464566929134 },
        { _T("01 M"),        28.3464566929134 },
        { _T("01 M"),        28.3464566929134 },

        /* unit without value */
        { _T("mm"),     0 },
        { _T("cm"),     0 },
        { _T("in"),     0 },
        { _T("\""),     0 },
        { _T("inch"),   0 },
        { _T("inches"), 0 },
        { _T("tw"),     0 },
        { _T("twip"),   0 },
        { _T("twips"),  0 },
        { _T("pt"),     0 },
        { _T("point"),  0 },
        { _T("points"), 0 },

        /* value without unit */
        { _T("1"),   1   },
        { _T("0.1"), 0.1 },

#if defined UNUSED
        { _T("1cmm"), 0 },  /* unknown unit (causes warning) */
#endif

        { NULL, -1 }  /* terminates loop */
    };

    int  i = 0;
    while (!(test[i].number_and_unit_ == NULL &&
             CAST(int, test[i].expect_result) == -1)) {

        chars_t        number_and_unit_ = test[i].number_and_unit_;
        const pixel_t  expect_result    = test[i].expect_result;
        const pixel_t  result = convert_to_pdf_points(number_and_unit_);

        if (((result - expect_result) < -0.0000001) ||
            ((result - expect_result) > 0.0000001)) {
            PRINTF_T(_T("\r\n") _T("Failed: convert_to_pdf_points(%s)")
                     _T(" != '%f' (returned '%f')"),
                     number_and_unit_, expect_result, result);
            DEBUG_BREAK;
        }
        i++;
    }
    RETURN(NIL);
} /* test_convert_to_pdf_points */
#endif                                              /* PDF_EXTRA_FEATURES > 0 */


END_NAMESPACE  /*c_*/
#endif                                                                   /*eof*/

/* TODO: create method Inject(pdfCode_). */
/* TODO: Handling of non-Latin Unicode characters */
/* TODO: create C++ wrapper */
